// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: treat.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as common from "./common.pb";

//========================================//
//                 Types                  //
//========================================//

/**
 * Treat represents a reward or treat given to a user
 */
export interface Treat {
  id: string;
  userId: string;
  treatType: string;
  title: string;
  description: string;
  points: number;
  imageUrl: string;
  awardedBy: string;
  applicationId: string;
  metadata: Record<string, Treat.Metadata["value"] | undefined>;
  awardedAt: protoscript.Timestamp;
  expiresAt: protoscript.Timestamp;
  createdAt: protoscript.Timestamp;
  updatedAt: protoscript.Timestamp;
}

export declare namespace Treat {
  interface Metadata {
    key: string;
    value: string;
  }
}

/**
 * Request to award a treat to a user
 */
export interface AwardTreatRequest {
  userId: string;
  treatType: string;
  title: string;
  description: string;
  points: number;
  imageUrl: string;
  awardedBy: string;
  applicationId: string;
  metadata: Record<string, AwardTreatRequest.Metadata["value"] | undefined>;
  expiresAt: protoscript.Timestamp;
}

export declare namespace AwardTreatRequest {
  interface Metadata {
    key: string;
    value: string;
  }
}

/**
 * Response containing a single treat
 */
export interface TreatResponse {
  status: common.ResponseStatus;
  treat: Treat;
}

/**
 * Request to get a treat by ID
 */
export interface GetTreatRequest {
  id: string;
}

/**
 * Request to update a treat
 */
export interface UpdateTreatRequest {
  id: string;
  title: string;
  description: string;
  points: number;
  imageUrl: string;
  metadata: Record<string, UpdateTreatRequest.Metadata["value"] | undefined>;
  expiresAt: protoscript.Timestamp;
}

export declare namespace UpdateTreatRequest {
  interface Metadata {
    key: string;
    value: string;
  }
}

/**
 * Request to delete a treat
 */
export interface DeleteTreatRequest {
  id: string;
}

/**
 * Request to list treats with filtering
 */
export interface ListTreatsRequest {
  userId: string;
  treatType: string;
  applicationId: string;
  fromDate: protoscript.Timestamp;
  toDate: protoscript.Timestamp;
  includeExpired: boolean;
  minPoints: number;
  maxPoints: number;
  page: number;
  pageSize: number;
  sortBy: string;
  sortDesc: boolean;
}

/**
 * Response containing a list of treats
 */
export interface ListTreatsResponse {
  status: common.ResponseStatus;
  treats: Treat[];
  totalCount: number;
  page: number;
  pageSize: number;
}

/**
 * Request to get a summary of treats for a user
 */
export interface GetUserTreatsSummaryRequest {
  userId: string;
  applicationId: string;
  fromDate: protoscript.Timestamp;
  toDate: protoscript.Timestamp;
}

/**
 * Summary of treats for a user
 */
export interface TreatsSummary {
  userId: string;
  totalTreats: number;
  totalPoints: number;
  pointsByType: Record<string, TreatsSummary.PointsByType["value"] | undefined>;
  recentTreats: Treat[];
  fromDate: protoscript.Timestamp;
  toDate: protoscript.Timestamp;
}

export declare namespace TreatsSummary {
  interface PointsByType {
    key: string;
    value: number;
  }
}

/**
 * Response containing a treats summary
 */
export interface TreatsSummaryResponse {
  status: common.ResponseStatus;
  summary: TreatsSummary;
}

/**
 * Request to get treat statistics
 */
export interface GetTreatStatsRequest {
  applicationId: string;
  fromDate: protoscript.Timestamp;
  toDate: protoscript.Timestamp;
  groupBy: string;
  userIds: string[];
  treatTypes: string[];
}

/**
 * Statistics about treats
 */
export interface TreatStats {
  dataPoints: TreatStats.DataPoint[];
  totalTreats: number;
  totalPoints: number;
  uniqueUsers: number;
  pointsByType: Record<string, TreatStats.PointsByType["value"] | undefined>;
  fromDate: protoscript.Timestamp;
  toDate: protoscript.Timestamp;
}

export declare namespace TreatStats {
  export interface DataPoint {
    label: string;
    count: number;
    totalPoints: number;
    pointsByType: Record<
      string,
      TreatStats.DataPoint.PointsByType["value"] | undefined
    >;
  }

  namespace DataPoint {
    interface PointsByType {
      key: string;
      value: number;
    }
  }

  interface PointsByType {
    key: string;
    value: number;
  }
}

/**
 * Response containing treat statistics
 */
export interface TreatStatsResponse {
  status: common.ResponseStatus;
  stats: TreatStats;
}

//========================================//
//      TreatService Protobuf Client      //
//========================================//

/**
 * Award a treat to a user
 */
export async function AwardTreat(
  awardTreatRequest: AwardTreatRequest,
  config?: ClientConfiguration,
): Promise<TreatResponse> {
  const response = await PBrequest(
    "/treat.TreatService/AwardTreat",
    AwardTreatRequest.encode(awardTreatRequest),
    config,
  );
  return TreatResponse.decode(response);
}

/**
 * Get a treat by ID
 */
export async function GetTreat(
  getTreatRequest: GetTreatRequest,
  config?: ClientConfiguration,
): Promise<TreatResponse> {
  const response = await PBrequest(
    "/treat.TreatService/GetTreat",
    GetTreatRequest.encode(getTreatRequest),
    config,
  );
  return TreatResponse.decode(response);
}

/**
 * Update a treat
 */
export async function UpdateTreat(
  updateTreatRequest: UpdateTreatRequest,
  config?: ClientConfiguration,
): Promise<TreatResponse> {
  const response = await PBrequest(
    "/treat.TreatService/UpdateTreat",
    UpdateTreatRequest.encode(updateTreatRequest),
    config,
  );
  return TreatResponse.decode(response);
}

/**
 * Delete a treat
 */
export async function DeleteTreat(
  deleteTreatRequest: DeleteTreatRequest,
  config?: ClientConfiguration,
): Promise<common.ResponseStatus> {
  const response = await PBrequest(
    "/treat.TreatService/DeleteTreat",
    DeleteTreatRequest.encode(deleteTreatRequest),
    config,
  );
  return common.ResponseStatus.decode(response);
}

/**
 * List treats with filtering
 */
export async function ListTreats(
  listTreatsRequest: ListTreatsRequest,
  config?: ClientConfiguration,
): Promise<ListTreatsResponse> {
  const response = await PBrequest(
    "/treat.TreatService/ListTreats",
    ListTreatsRequest.encode(listTreatsRequest),
    config,
  );
  return ListTreatsResponse.decode(response);
}

/**
 * Get a summary of treats for a user
 */
export async function GetUserTreatsSummary(
  getUserTreatsSummaryRequest: GetUserTreatsSummaryRequest,
  config?: ClientConfiguration,
): Promise<TreatsSummaryResponse> {
  const response = await PBrequest(
    "/treat.TreatService/GetUserTreatsSummary",
    GetUserTreatsSummaryRequest.encode(getUserTreatsSummaryRequest),
    config,
  );
  return TreatsSummaryResponse.decode(response);
}

/**
 * Get treat statistics
 */
export async function GetTreatStats(
  getTreatStatsRequest: GetTreatStatsRequest,
  config?: ClientConfiguration,
): Promise<TreatStatsResponse> {
  const response = await PBrequest(
    "/treat.TreatService/GetTreatStats",
    GetTreatStatsRequest.encode(getTreatStatsRequest),
    config,
  );
  return TreatStatsResponse.decode(response);
}

//========================================//
//        TreatService JSON Client        //
//========================================//

/**
 * Award a treat to a user
 */
export async function AwardTreatJSON(
  awardTreatRequest: AwardTreatRequest,
  config?: ClientConfiguration,
): Promise<TreatResponse> {
  const response = await JSONrequest(
    "/treat.TreatService/AwardTreat",
    AwardTreatRequestJSON.encode(awardTreatRequest),
    config,
  );
  return TreatResponseJSON.decode(response);
}

/**
 * Get a treat by ID
 */
export async function GetTreatJSON(
  getTreatRequest: GetTreatRequest,
  config?: ClientConfiguration,
): Promise<TreatResponse> {
  const response = await JSONrequest(
    "/treat.TreatService/GetTreat",
    GetTreatRequestJSON.encode(getTreatRequest),
    config,
  );
  return TreatResponseJSON.decode(response);
}

/**
 * Update a treat
 */
export async function UpdateTreatJSON(
  updateTreatRequest: UpdateTreatRequest,
  config?: ClientConfiguration,
): Promise<TreatResponse> {
  const response = await JSONrequest(
    "/treat.TreatService/UpdateTreat",
    UpdateTreatRequestJSON.encode(updateTreatRequest),
    config,
  );
  return TreatResponseJSON.decode(response);
}

/**
 * Delete a treat
 */
export async function DeleteTreatJSON(
  deleteTreatRequest: DeleteTreatRequest,
  config?: ClientConfiguration,
): Promise<common.ResponseStatus> {
  const response = await JSONrequest(
    "/treat.TreatService/DeleteTreat",
    DeleteTreatRequestJSON.encode(deleteTreatRequest),
    config,
  );
  return common.ResponseStatusJSON.decode(response);
}

/**
 * List treats with filtering
 */
export async function ListTreatsJSON(
  listTreatsRequest: ListTreatsRequest,
  config?: ClientConfiguration,
): Promise<ListTreatsResponse> {
  const response = await JSONrequest(
    "/treat.TreatService/ListTreats",
    ListTreatsRequestJSON.encode(listTreatsRequest),
    config,
  );
  return ListTreatsResponseJSON.decode(response);
}

/**
 * Get a summary of treats for a user
 */
export async function GetUserTreatsSummaryJSON(
  getUserTreatsSummaryRequest: GetUserTreatsSummaryRequest,
  config?: ClientConfiguration,
): Promise<TreatsSummaryResponse> {
  const response = await JSONrequest(
    "/treat.TreatService/GetUserTreatsSummary",
    GetUserTreatsSummaryRequestJSON.encode(getUserTreatsSummaryRequest),
    config,
  );
  return TreatsSummaryResponseJSON.decode(response);
}

/**
 * Get treat statistics
 */
export async function GetTreatStatsJSON(
  getTreatStatsRequest: GetTreatStatsRequest,
  config?: ClientConfiguration,
): Promise<TreatStatsResponse> {
  const response = await JSONrequest(
    "/treat.TreatService/GetTreatStats",
    GetTreatStatsRequestJSON.encode(getTreatStatsRequest),
    config,
  );
  return TreatStatsResponseJSON.decode(response);
}

//========================================//
//              TreatService              //
//========================================//

export interface TreatService<Context = unknown> {
  /**
   * Award a treat to a user
   */
  AwardTreat: (
    awardTreatRequest: AwardTreatRequest,
    context: Context,
  ) => Promise<TreatResponse> | TreatResponse;
  /**
   * Get a treat by ID
   */
  GetTreat: (
    getTreatRequest: GetTreatRequest,
    context: Context,
  ) => Promise<TreatResponse> | TreatResponse;
  /**
   * Update a treat
   */
  UpdateTreat: (
    updateTreatRequest: UpdateTreatRequest,
    context: Context,
  ) => Promise<TreatResponse> | TreatResponse;
  /**
   * Delete a treat
   */
  DeleteTreat: (
    deleteTreatRequest: DeleteTreatRequest,
    context: Context,
  ) => Promise<common.ResponseStatus> | common.ResponseStatus;
  /**
   * List treats with filtering
   */
  ListTreats: (
    listTreatsRequest: ListTreatsRequest,
    context: Context,
  ) => Promise<ListTreatsResponse> | ListTreatsResponse;
  /**
   * Get a summary of treats for a user
   */
  GetUserTreatsSummary: (
    getUserTreatsSummaryRequest: GetUserTreatsSummaryRequest,
    context: Context,
  ) => Promise<TreatsSummaryResponse> | TreatsSummaryResponse;
  /**
   * Get treat statistics
   */
  GetTreatStats: (
    getTreatStatsRequest: GetTreatStatsRequest,
    context: Context,
  ) => Promise<TreatStatsResponse> | TreatStatsResponse;
}

export function createTreatService<Context>(service: TreatService<Context>) {
  return {
    name: "treat.TreatService",
    methods: {
      AwardTreat: {
        name: "AwardTreat",
        handler: service.AwardTreat,
        input: { protobuf: AwardTreatRequest, json: AwardTreatRequestJSON },
        output: { protobuf: TreatResponse, json: TreatResponseJSON },
      },
      GetTreat: {
        name: "GetTreat",
        handler: service.GetTreat,
        input: { protobuf: GetTreatRequest, json: GetTreatRequestJSON },
        output: { protobuf: TreatResponse, json: TreatResponseJSON },
      },
      UpdateTreat: {
        name: "UpdateTreat",
        handler: service.UpdateTreat,
        input: { protobuf: UpdateTreatRequest, json: UpdateTreatRequestJSON },
        output: { protobuf: TreatResponse, json: TreatResponseJSON },
      },
      DeleteTreat: {
        name: "DeleteTreat",
        handler: service.DeleteTreat,
        input: { protobuf: DeleteTreatRequest, json: DeleteTreatRequestJSON },
        output: {
          protobuf: common.ResponseStatus,
          json: common.ResponseStatusJSON,
        },
      },
      ListTreats: {
        name: "ListTreats",
        handler: service.ListTreats,
        input: { protobuf: ListTreatsRequest, json: ListTreatsRequestJSON },
        output: { protobuf: ListTreatsResponse, json: ListTreatsResponseJSON },
      },
      GetUserTreatsSummary: {
        name: "GetUserTreatsSummary",
        handler: service.GetUserTreatsSummary,
        input: {
          protobuf: GetUserTreatsSummaryRequest,
          json: GetUserTreatsSummaryRequestJSON,
        },
        output: {
          protobuf: TreatsSummaryResponse,
          json: TreatsSummaryResponseJSON,
        },
      },
      GetTreatStats: {
        name: "GetTreatStats",
        handler: service.GetTreatStats,
        input: {
          protobuf: GetTreatStatsRequest,
          json: GetTreatStatsRequestJSON,
        },
        output: { protobuf: TreatStatsResponse, json: TreatStatsResponseJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Treat = {
  /**
   * Serializes Treat to protobuf.
   */
  encode: function (msg: PartialDeep<Treat>): Uint8Array {
    return Treat._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Treat from protobuf.
   */
  decode: function (bytes: ByteSource): Treat {
    return Treat._readMessage(
      Treat.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Treat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Treat>): Treat {
    return {
      id: "",
      userId: "",
      treatType: "",
      title: "",
      description: "",
      points: 0,
      imageUrl: "",
      awardedBy: "",
      applicationId: "",
      metadata: {},
      awardedAt: protoscript.Timestamp.initialize(),
      expiresAt: protoscript.Timestamp.initialize(),
      createdAt: protoscript.Timestamp.initialize(),
      updatedAt: protoscript.Timestamp.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Treat>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.userId) {
      writer.writeString(2, msg.userId);
    }
    if (msg.treatType) {
      writer.writeString(3, msg.treatType);
    }
    if (msg.title) {
      writer.writeString(4, msg.title);
    }
    if (msg.description) {
      writer.writeString(5, msg.description);
    }
    if (msg.points) {
      writer.writeInt32(6, msg.points);
    }
    if (msg.imageUrl) {
      writer.writeString(7, msg.imageUrl);
    }
    if (msg.awardedBy) {
      writer.writeString(8, msg.awardedBy);
    }
    if (msg.applicationId) {
      writer.writeString(9, msg.applicationId);
    }
    if (msg.metadata) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.metadata).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        Treat.Metadata._writeMessage,
      );
    }
    if (msg.awardedAt) {
      writer.writeMessage(
        11,
        msg.awardedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.expiresAt) {
      writer.writeMessage(
        12,
        msg.expiresAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.createdAt) {
      writer.writeMessage(
        13,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.updatedAt) {
      writer.writeMessage(
        14,
        msg.updatedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Treat, reader: protoscript.BinaryReader): Treat {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.userId = reader.readString();
          break;
        }
        case 3: {
          msg.treatType = reader.readString();
          break;
        }
        case 4: {
          msg.title = reader.readString();
          break;
        }
        case 5: {
          msg.description = reader.readString();
          break;
        }
        case 6: {
          msg.points = reader.readInt32();
          break;
        }
        case 7: {
          msg.imageUrl = reader.readString();
          break;
        }
        case 8: {
          msg.awardedBy = reader.readString();
          break;
        }
        case 9: {
          msg.applicationId = reader.readString();
          break;
        }
        case 10: {
          const map = {} as Treat.Metadata;
          reader.readMessage(map, Treat.Metadata._readMessage);
          msg.metadata[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          reader.readMessage(msg.awardedAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 12: {
          reader.readMessage(msg.expiresAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 13: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 14: {
          reader.readMessage(msg.updatedAt, protoscript.Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Metadata: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Treat.Metadata>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Treat.Metadata,
      reader: protoscript.BinaryReader,
    ): Treat.Metadata {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const AwardTreatRequest = {
  /**
   * Serializes AwardTreatRequest to protobuf.
   */
  encode: function (msg: PartialDeep<AwardTreatRequest>): Uint8Array {
    return AwardTreatRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes AwardTreatRequest from protobuf.
   */
  decode: function (bytes: ByteSource): AwardTreatRequest {
    return AwardTreatRequest._readMessage(
      AwardTreatRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes AwardTreatRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<AwardTreatRequest>): AwardTreatRequest {
    return {
      userId: "",
      treatType: "",
      title: "",
      description: "",
      points: 0,
      imageUrl: "",
      awardedBy: "",
      applicationId: "",
      metadata: {},
      expiresAt: protoscript.Timestamp.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<AwardTreatRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.userId) {
      writer.writeString(1, msg.userId);
    }
    if (msg.treatType) {
      writer.writeString(2, msg.treatType);
    }
    if (msg.title) {
      writer.writeString(3, msg.title);
    }
    if (msg.description) {
      writer.writeString(4, msg.description);
    }
    if (msg.points) {
      writer.writeInt32(5, msg.points);
    }
    if (msg.imageUrl) {
      writer.writeString(6, msg.imageUrl);
    }
    if (msg.awardedBy) {
      writer.writeString(7, msg.awardedBy);
    }
    if (msg.applicationId) {
      writer.writeString(8, msg.applicationId);
    }
    if (msg.metadata) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.metadata).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        AwardTreatRequest.Metadata._writeMessage,
      );
    }
    if (msg.expiresAt) {
      writer.writeMessage(
        10,
        msg.expiresAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: AwardTreatRequest,
    reader: protoscript.BinaryReader,
  ): AwardTreatRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.userId = reader.readString();
          break;
        }
        case 2: {
          msg.treatType = reader.readString();
          break;
        }
        case 3: {
          msg.title = reader.readString();
          break;
        }
        case 4: {
          msg.description = reader.readString();
          break;
        }
        case 5: {
          msg.points = reader.readInt32();
          break;
        }
        case 6: {
          msg.imageUrl = reader.readString();
          break;
        }
        case 7: {
          msg.awardedBy = reader.readString();
          break;
        }
        case 8: {
          msg.applicationId = reader.readString();
          break;
        }
        case 9: {
          const map = {} as AwardTreatRequest.Metadata;
          reader.readMessage(map, AwardTreatRequest.Metadata._readMessage);
          msg.metadata[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          reader.readMessage(msg.expiresAt, protoscript.Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Metadata: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<AwardTreatRequest.Metadata>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: AwardTreatRequest.Metadata,
      reader: protoscript.BinaryReader,
    ): AwardTreatRequest.Metadata {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TreatResponse = {
  /**
   * Serializes TreatResponse to protobuf.
   */
  encode: function (msg: PartialDeep<TreatResponse>): Uint8Array {
    return TreatResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TreatResponse from protobuf.
   */
  decode: function (bytes: ByteSource): TreatResponse {
    return TreatResponse._readMessage(
      TreatResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TreatResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TreatResponse>): TreatResponse {
    return {
      status: common.ResponseStatus.initialize(),
      treat: Treat.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TreatResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.status) {
      writer.writeMessage(1, msg.status, common.ResponseStatus._writeMessage);
    }
    if (msg.treat) {
      writer.writeMessage(2, msg.treat, Treat._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TreatResponse,
    reader: protoscript.BinaryReader,
  ): TreatResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.status, common.ResponseStatus._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.treat, Treat._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetTreatRequest = {
  /**
   * Serializes GetTreatRequest to protobuf.
   */
  encode: function (msg: PartialDeep<GetTreatRequest>): Uint8Array {
    return GetTreatRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GetTreatRequest from protobuf.
   */
  decode: function (bytes: ByteSource): GetTreatRequest {
    return GetTreatRequest._readMessage(
      GetTreatRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GetTreatRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetTreatRequest>): GetTreatRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetTreatRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetTreatRequest,
    reader: protoscript.BinaryReader,
  ): GetTreatRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const UpdateTreatRequest = {
  /**
   * Serializes UpdateTreatRequest to protobuf.
   */
  encode: function (msg: PartialDeep<UpdateTreatRequest>): Uint8Array {
    return UpdateTreatRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes UpdateTreatRequest from protobuf.
   */
  decode: function (bytes: ByteSource): UpdateTreatRequest {
    return UpdateTreatRequest._readMessage(
      UpdateTreatRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes UpdateTreatRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<UpdateTreatRequest>): UpdateTreatRequest {
    return {
      id: "",
      title: "",
      description: "",
      points: 0,
      imageUrl: "",
      metadata: {},
      expiresAt: protoscript.Timestamp.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UpdateTreatRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.title) {
      writer.writeString(2, msg.title);
    }
    if (msg.description) {
      writer.writeString(3, msg.description);
    }
    if (msg.points) {
      writer.writeInt32(4, msg.points);
    }
    if (msg.imageUrl) {
      writer.writeString(5, msg.imageUrl);
    }
    if (msg.metadata) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.metadata).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        UpdateTreatRequest.Metadata._writeMessage,
      );
    }
    if (msg.expiresAt) {
      writer.writeMessage(
        7,
        msg.expiresAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UpdateTreatRequest,
    reader: protoscript.BinaryReader,
  ): UpdateTreatRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.title = reader.readString();
          break;
        }
        case 3: {
          msg.description = reader.readString();
          break;
        }
        case 4: {
          msg.points = reader.readInt32();
          break;
        }
        case 5: {
          msg.imageUrl = reader.readString();
          break;
        }
        case 6: {
          const map = {} as UpdateTreatRequest.Metadata;
          reader.readMessage(map, UpdateTreatRequest.Metadata._readMessage);
          msg.metadata[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          reader.readMessage(msg.expiresAt, protoscript.Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Metadata: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<UpdateTreatRequest.Metadata>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: UpdateTreatRequest.Metadata,
      reader: protoscript.BinaryReader,
    ): UpdateTreatRequest.Metadata {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const DeleteTreatRequest = {
  /**
   * Serializes DeleteTreatRequest to protobuf.
   */
  encode: function (msg: PartialDeep<DeleteTreatRequest>): Uint8Array {
    return DeleteTreatRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes DeleteTreatRequest from protobuf.
   */
  decode: function (bytes: ByteSource): DeleteTreatRequest {
    return DeleteTreatRequest._readMessage(
      DeleteTreatRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes DeleteTreatRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<DeleteTreatRequest>): DeleteTreatRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DeleteTreatRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DeleteTreatRequest,
    reader: protoscript.BinaryReader,
  ): DeleteTreatRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListTreatsRequest = {
  /**
   * Serializes ListTreatsRequest to protobuf.
   */
  encode: function (msg: PartialDeep<ListTreatsRequest>): Uint8Array {
    return ListTreatsRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListTreatsRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ListTreatsRequest {
    return ListTreatsRequest._readMessage(
      ListTreatsRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListTreatsRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListTreatsRequest>): ListTreatsRequest {
    return {
      userId: "",
      treatType: "",
      applicationId: "",
      fromDate: protoscript.Timestamp.initialize(),
      toDate: protoscript.Timestamp.initialize(),
      includeExpired: false,
      minPoints: 0,
      maxPoints: 0,
      page: 0,
      pageSize: 0,
      sortBy: "",
      sortDesc: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTreatsRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.userId) {
      writer.writeString(1, msg.userId);
    }
    if (msg.treatType) {
      writer.writeString(2, msg.treatType);
    }
    if (msg.applicationId) {
      writer.writeString(3, msg.applicationId);
    }
    if (msg.fromDate) {
      writer.writeMessage(4, msg.fromDate, protoscript.Timestamp._writeMessage);
    }
    if (msg.toDate) {
      writer.writeMessage(5, msg.toDate, protoscript.Timestamp._writeMessage);
    }
    if (msg.includeExpired) {
      writer.writeBool(6, msg.includeExpired);
    }
    if (msg.minPoints) {
      writer.writeInt32(7, msg.minPoints);
    }
    if (msg.maxPoints) {
      writer.writeInt32(8, msg.maxPoints);
    }
    if (msg.page) {
      writer.writeInt32(9, msg.page);
    }
    if (msg.pageSize) {
      writer.writeInt32(10, msg.pageSize);
    }
    if (msg.sortBy) {
      writer.writeString(11, msg.sortBy);
    }
    if (msg.sortDesc) {
      writer.writeBool(12, msg.sortDesc);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTreatsRequest,
    reader: protoscript.BinaryReader,
  ): ListTreatsRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.userId = reader.readString();
          break;
        }
        case 2: {
          msg.treatType = reader.readString();
          break;
        }
        case 3: {
          msg.applicationId = reader.readString();
          break;
        }
        case 4: {
          reader.readMessage(msg.fromDate, protoscript.Timestamp._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(msg.toDate, protoscript.Timestamp._readMessage);
          break;
        }
        case 6: {
          msg.includeExpired = reader.readBool();
          break;
        }
        case 7: {
          msg.minPoints = reader.readInt32();
          break;
        }
        case 8: {
          msg.maxPoints = reader.readInt32();
          break;
        }
        case 9: {
          msg.page = reader.readInt32();
          break;
        }
        case 10: {
          msg.pageSize = reader.readInt32();
          break;
        }
        case 11: {
          msg.sortBy = reader.readString();
          break;
        }
        case 12: {
          msg.sortDesc = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListTreatsResponse = {
  /**
   * Serializes ListTreatsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListTreatsResponse>): Uint8Array {
    return ListTreatsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListTreatsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListTreatsResponse {
    return ListTreatsResponse._readMessage(
      ListTreatsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListTreatsResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListTreatsResponse>): ListTreatsResponse {
    return {
      status: common.ResponseStatus.initialize(),
      treats: [],
      totalCount: 0,
      page: 0,
      pageSize: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTreatsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.status) {
      writer.writeMessage(1, msg.status, common.ResponseStatus._writeMessage);
    }
    if (msg.treats?.length) {
      writer.writeRepeatedMessage(2, msg.treats as any, Treat._writeMessage);
    }
    if (msg.totalCount) {
      writer.writeInt32(3, msg.totalCount);
    }
    if (msg.page) {
      writer.writeInt32(4, msg.page);
    }
    if (msg.pageSize) {
      writer.writeInt32(5, msg.pageSize);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTreatsResponse,
    reader: protoscript.BinaryReader,
  ): ListTreatsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.status, common.ResponseStatus._readMessage);
          break;
        }
        case 2: {
          const m = Treat.initialize();
          reader.readMessage(m, Treat._readMessage);
          msg.treats.push(m);
          break;
        }
        case 3: {
          msg.totalCount = reader.readInt32();
          break;
        }
        case 4: {
          msg.page = reader.readInt32();
          break;
        }
        case 5: {
          msg.pageSize = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetUserTreatsSummaryRequest = {
  /**
   * Serializes GetUserTreatsSummaryRequest to protobuf.
   */
  encode: function (msg: PartialDeep<GetUserTreatsSummaryRequest>): Uint8Array {
    return GetUserTreatsSummaryRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GetUserTreatsSummaryRequest from protobuf.
   */
  decode: function (bytes: ByteSource): GetUserTreatsSummaryRequest {
    return GetUserTreatsSummaryRequest._readMessage(
      GetUserTreatsSummaryRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GetUserTreatsSummaryRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetUserTreatsSummaryRequest>,
  ): GetUserTreatsSummaryRequest {
    return {
      userId: "",
      applicationId: "",
      fromDate: protoscript.Timestamp.initialize(),
      toDate: protoscript.Timestamp.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetUserTreatsSummaryRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.userId) {
      writer.writeString(1, msg.userId);
    }
    if (msg.applicationId) {
      writer.writeString(2, msg.applicationId);
    }
    if (msg.fromDate) {
      writer.writeMessage(3, msg.fromDate, protoscript.Timestamp._writeMessage);
    }
    if (msg.toDate) {
      writer.writeMessage(4, msg.toDate, protoscript.Timestamp._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetUserTreatsSummaryRequest,
    reader: protoscript.BinaryReader,
  ): GetUserTreatsSummaryRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.userId = reader.readString();
          break;
        }
        case 2: {
          msg.applicationId = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fromDate, protoscript.Timestamp._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.toDate, protoscript.Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TreatsSummary = {
  /**
   * Serializes TreatsSummary to protobuf.
   */
  encode: function (msg: PartialDeep<TreatsSummary>): Uint8Array {
    return TreatsSummary._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TreatsSummary from protobuf.
   */
  decode: function (bytes: ByteSource): TreatsSummary {
    return TreatsSummary._readMessage(
      TreatsSummary.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TreatsSummary with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TreatsSummary>): TreatsSummary {
    return {
      userId: "",
      totalTreats: 0,
      totalPoints: 0,
      pointsByType: {},
      recentTreats: [],
      fromDate: protoscript.Timestamp.initialize(),
      toDate: protoscript.Timestamp.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TreatsSummary>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.userId) {
      writer.writeString(1, msg.userId);
    }
    if (msg.totalTreats) {
      writer.writeInt32(2, msg.totalTreats);
    }
    if (msg.totalPoints) {
      writer.writeInt32(3, msg.totalPoints);
    }
    if (msg.pointsByType) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.pointsByType).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TreatsSummary.PointsByType._writeMessage,
      );
    }
    if (msg.recentTreats?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.recentTreats as any,
        Treat._writeMessage,
      );
    }
    if (msg.fromDate) {
      writer.writeMessage(6, msg.fromDate, protoscript.Timestamp._writeMessage);
    }
    if (msg.toDate) {
      writer.writeMessage(7, msg.toDate, protoscript.Timestamp._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TreatsSummary,
    reader: protoscript.BinaryReader,
  ): TreatsSummary {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.userId = reader.readString();
          break;
        }
        case 2: {
          msg.totalTreats = reader.readInt32();
          break;
        }
        case 3: {
          msg.totalPoints = reader.readInt32();
          break;
        }
        case 4: {
          const map = {} as TreatsSummary.PointsByType;
          reader.readMessage(map, TreatsSummary.PointsByType._readMessage);
          msg.pointsByType[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const m = Treat.initialize();
          reader.readMessage(m, Treat._readMessage);
          msg.recentTreats.push(m);
          break;
        }
        case 6: {
          reader.readMessage(msg.fromDate, protoscript.Timestamp._readMessage);
          break;
        }
        case 7: {
          reader.readMessage(msg.toDate, protoscript.Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  PointsByType: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TreatsSummary.PointsByType>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TreatsSummary.PointsByType,
      reader: protoscript.BinaryReader,
    ): TreatsSummary.PointsByType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TreatsSummaryResponse = {
  /**
   * Serializes TreatsSummaryResponse to protobuf.
   */
  encode: function (msg: PartialDeep<TreatsSummaryResponse>): Uint8Array {
    return TreatsSummaryResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TreatsSummaryResponse from protobuf.
   */
  decode: function (bytes: ByteSource): TreatsSummaryResponse {
    return TreatsSummaryResponse._readMessage(
      TreatsSummaryResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TreatsSummaryResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<TreatsSummaryResponse>,
  ): TreatsSummaryResponse {
    return {
      status: common.ResponseStatus.initialize(),
      summary: TreatsSummary.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TreatsSummaryResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.status) {
      writer.writeMessage(1, msg.status, common.ResponseStatus._writeMessage);
    }
    if (msg.summary) {
      writer.writeMessage(2, msg.summary, TreatsSummary._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TreatsSummaryResponse,
    reader: protoscript.BinaryReader,
  ): TreatsSummaryResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.status, common.ResponseStatus._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.summary, TreatsSummary._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetTreatStatsRequest = {
  /**
   * Serializes GetTreatStatsRequest to protobuf.
   */
  encode: function (msg: PartialDeep<GetTreatStatsRequest>): Uint8Array {
    return GetTreatStatsRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GetTreatStatsRequest from protobuf.
   */
  decode: function (bytes: ByteSource): GetTreatStatsRequest {
    return GetTreatStatsRequest._readMessage(
      GetTreatStatsRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GetTreatStatsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetTreatStatsRequest>,
  ): GetTreatStatsRequest {
    return {
      applicationId: "",
      fromDate: protoscript.Timestamp.initialize(),
      toDate: protoscript.Timestamp.initialize(),
      groupBy: "",
      userIds: [],
      treatTypes: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetTreatStatsRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.applicationId) {
      writer.writeString(1, msg.applicationId);
    }
    if (msg.fromDate) {
      writer.writeMessage(2, msg.fromDate, protoscript.Timestamp._writeMessage);
    }
    if (msg.toDate) {
      writer.writeMessage(3, msg.toDate, protoscript.Timestamp._writeMessage);
    }
    if (msg.groupBy) {
      writer.writeString(4, msg.groupBy);
    }
    if (msg.userIds?.length) {
      writer.writeRepeatedString(5, msg.userIds);
    }
    if (msg.treatTypes?.length) {
      writer.writeRepeatedString(6, msg.treatTypes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetTreatStatsRequest,
    reader: protoscript.BinaryReader,
  ): GetTreatStatsRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.applicationId = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.fromDate, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.toDate, protoscript.Timestamp._readMessage);
          break;
        }
        case 4: {
          msg.groupBy = reader.readString();
          break;
        }
        case 5: {
          msg.userIds.push(reader.readString());
          break;
        }
        case 6: {
          msg.treatTypes.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TreatStats = {
  /**
   * Serializes TreatStats to protobuf.
   */
  encode: function (msg: PartialDeep<TreatStats>): Uint8Array {
    return TreatStats._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TreatStats from protobuf.
   */
  decode: function (bytes: ByteSource): TreatStats {
    return TreatStats._readMessage(
      TreatStats.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TreatStats with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TreatStats>): TreatStats {
    return {
      dataPoints: [],
      totalTreats: 0,
      totalPoints: 0,
      uniqueUsers: 0,
      pointsByType: {},
      fromDate: protoscript.Timestamp.initialize(),
      toDate: protoscript.Timestamp.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TreatStats>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.dataPoints?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.dataPoints as any,
        TreatStats.DataPoint._writeMessage,
      );
    }
    if (msg.totalTreats) {
      writer.writeInt32(2, msg.totalTreats);
    }
    if (msg.totalPoints) {
      writer.writeInt32(3, msg.totalPoints);
    }
    if (msg.uniqueUsers) {
      writer.writeInt32(4, msg.uniqueUsers);
    }
    if (msg.pointsByType) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.pointsByType).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TreatStats.PointsByType._writeMessage,
      );
    }
    if (msg.fromDate) {
      writer.writeMessage(6, msg.fromDate, protoscript.Timestamp._writeMessage);
    }
    if (msg.toDate) {
      writer.writeMessage(7, msg.toDate, protoscript.Timestamp._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TreatStats,
    reader: protoscript.BinaryReader,
  ): TreatStats {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = TreatStats.DataPoint.initialize();
          reader.readMessage(m, TreatStats.DataPoint._readMessage);
          msg.dataPoints.push(m);
          break;
        }
        case 2: {
          msg.totalTreats = reader.readInt32();
          break;
        }
        case 3: {
          msg.totalPoints = reader.readInt32();
          break;
        }
        case 4: {
          msg.uniqueUsers = reader.readInt32();
          break;
        }
        case 5: {
          const map = {} as TreatStats.PointsByType;
          reader.readMessage(map, TreatStats.PointsByType._readMessage);
          msg.pointsByType[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          reader.readMessage(msg.fromDate, protoscript.Timestamp._readMessage);
          break;
        }
        case 7: {
          reader.readMessage(msg.toDate, protoscript.Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DataPoint: {
    /**
     * Serializes TreatStats.DataPoint to protobuf.
     */
    encode: function (msg: PartialDeep<TreatStats.DataPoint>): Uint8Array {
      return TreatStats.DataPoint._writeMessage(
        msg,
        new protoscript.BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TreatStats.DataPoint from protobuf.
     */
    decode: function (bytes: ByteSource): TreatStats.DataPoint {
      return TreatStats.DataPoint._readMessage(
        TreatStats.DataPoint.initialize(),
        new protoscript.BinaryReader(bytes),
      );
    },

    /**
     * Initializes TreatStats.DataPoint with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<TreatStats.DataPoint>,
    ): TreatStats.DataPoint {
      return {
        label: "",
        count: 0,
        totalPoints: 0,
        pointsByType: {},
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TreatStats.DataPoint>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.label) {
        writer.writeString(1, msg.label);
      }
      if (msg.count) {
        writer.writeInt32(2, msg.count);
      }
      if (msg.totalPoints) {
        writer.writeInt32(3, msg.totalPoints);
      }
      if (msg.pointsByType) {
        writer.writeRepeatedMessage(
          4,
          Object.entries(msg.pointsByType).map(([key, value]) => ({
            key: key as any,
            value: value as any,
          })) as any,
          TreatStats.DataPoint.PointsByType._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TreatStats.DataPoint,
      reader: protoscript.BinaryReader,
    ): TreatStats.DataPoint {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.label = reader.readString();
            break;
          }
          case 2: {
            msg.count = reader.readInt32();
            break;
          }
          case 3: {
            msg.totalPoints = reader.readInt32();
            break;
          }
          case 4: {
            const map = {} as TreatStats.DataPoint.PointsByType;
            reader.readMessage(
              map,
              TreatStats.DataPoint.PointsByType._readMessage,
            );
            msg.pointsByType[map.key.toString()] = map.value;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    PointsByType: {
      /**
       * @private
       */
      _writeMessage: function (
        msg: PartialDeep<TreatStats.DataPoint.PointsByType>,
        writer: protoscript.BinaryWriter,
      ): protoscript.BinaryWriter {
        if (msg.key) {
          writer.writeString(1, msg.key);
        }
        if (msg.value) {
          writer.writeInt32(2, msg.value);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TreatStats.DataPoint.PointsByType,
        reader: protoscript.BinaryReader,
      ): TreatStats.DataPoint.PointsByType {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.key = reader.readString();
              break;
            }
            case 2: {
              msg.value = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  PointsByType: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TreatStats.PointsByType>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TreatStats.PointsByType,
      reader: protoscript.BinaryReader,
    ): TreatStats.PointsByType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TreatStatsResponse = {
  /**
   * Serializes TreatStatsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<TreatStatsResponse>): Uint8Array {
    return TreatStatsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TreatStatsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): TreatStatsResponse {
    return TreatStatsResponse._readMessage(
      TreatStatsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TreatStatsResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TreatStatsResponse>): TreatStatsResponse {
    return {
      status: common.ResponseStatus.initialize(),
      stats: TreatStats.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TreatStatsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.status) {
      writer.writeMessage(1, msg.status, common.ResponseStatus._writeMessage);
    }
    if (msg.stats) {
      writer.writeMessage(2, msg.stats, TreatStats._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TreatStatsResponse,
    reader: protoscript.BinaryReader,
  ): TreatStatsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.status, common.ResponseStatus._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.stats, TreatStats._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const TreatJSON = {
  /**
   * Serializes Treat to JSON.
   */
  encode: function (msg: PartialDeep<Treat>): string {
    return JSON.stringify(TreatJSON._writeMessage(msg));
  },

  /**
   * Deserializes Treat from JSON.
   */
  decode: function (json: string): Treat {
    return TreatJSON._readMessage(TreatJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Treat with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Treat>): Treat {
    return {
      id: "",
      userId: "",
      treatType: "",
      title: "",
      description: "",
      points: 0,
      imageUrl: "",
      awardedBy: "",
      applicationId: "",
      metadata: {},
      awardedAt: protoscript.TimestampJSON.initialize(),
      expiresAt: protoscript.TimestampJSON.initialize(),
      createdAt: protoscript.TimestampJSON.initialize(),
      updatedAt: protoscript.TimestampJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Treat>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.treatType) {
      json["treatType"] = msg.treatType;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    if (msg.points) {
      json["points"] = msg.points;
    }
    if (msg.imageUrl) {
      json["imageUrl"] = msg.imageUrl;
    }
    if (msg.awardedBy) {
      json["awardedBy"] = msg.awardedBy;
    }
    if (msg.applicationId) {
      json["applicationId"] = msg.applicationId;
    }
    if (msg.metadata) {
      const _metadata_ = Object.fromEntries(
        Object.entries(msg.metadata)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TreatJSON.Metadata._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_metadata_).length > 0) {
        json["metadata"] = _metadata_;
      }
    }
    if (msg.awardedAt && (msg.awardedAt.seconds || msg.awardedAt.nanos)) {
      json["awardedAt"] = protoscript.serializeTimestamp(msg.awardedAt);
    }
    if (msg.expiresAt && (msg.expiresAt.seconds || msg.expiresAt.nanos)) {
      json["expiresAt"] = protoscript.serializeTimestamp(msg.expiresAt);
    }
    if (msg.createdAt && (msg.createdAt.seconds || msg.createdAt.nanos)) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.updatedAt && (msg.updatedAt.seconds || msg.updatedAt.nanos)) {
      json["updatedAt"] = protoscript.serializeTimestamp(msg.updatedAt);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Treat, json: any): Treat {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _treatType_ = json["treatType"] ?? json["treat_type"];
    if (_treatType_) {
      msg.treatType = _treatType_;
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _points_ = json["points"];
    if (_points_) {
      msg.points = protoscript.parseNumber(_points_);
    }
    const _imageUrl_ = json["imageUrl"] ?? json["image_url"];
    if (_imageUrl_) {
      msg.imageUrl = _imageUrl_;
    }
    const _awardedBy_ = json["awardedBy"] ?? json["awarded_by"];
    if (_awardedBy_) {
      msg.awardedBy = _awardedBy_;
    }
    const _applicationId_ = json["applicationId"] ?? json["application_id"];
    if (_applicationId_) {
      msg.applicationId = _applicationId_;
    }
    const _metadata_ = json["metadata"];
    if (_metadata_) {
      msg.metadata = Object.fromEntries(
        Object.entries(_metadata_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TreatJSON.Metadata._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _awardedAt_ = json["awardedAt"] ?? json["awarded_at"];
    if (_awardedAt_) {
      msg.awardedAt = protoscript.parseTimestamp(_awardedAt_);
    }
    const _expiresAt_ = json["expiresAt"] ?? json["expires_at"];
    if (_expiresAt_) {
      msg.expiresAt = protoscript.parseTimestamp(_expiresAt_);
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _updatedAt_ = json["updatedAt"] ?? json["updated_at"];
    if (_updatedAt_) {
      msg.updatedAt = protoscript.parseTimestamp(_updatedAt_);
    }
    return msg;
  },

  Metadata: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Treat.Metadata>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Treat.Metadata, json: any): Treat.Metadata {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const AwardTreatRequestJSON = {
  /**
   * Serializes AwardTreatRequest to JSON.
   */
  encode: function (msg: PartialDeep<AwardTreatRequest>): string {
    return JSON.stringify(AwardTreatRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes AwardTreatRequest from JSON.
   */
  decode: function (json: string): AwardTreatRequest {
    return AwardTreatRequestJSON._readMessage(
      AwardTreatRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes AwardTreatRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<AwardTreatRequest>): AwardTreatRequest {
    return {
      userId: "",
      treatType: "",
      title: "",
      description: "",
      points: 0,
      imageUrl: "",
      awardedBy: "",
      applicationId: "",
      metadata: {},
      expiresAt: protoscript.TimestampJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<AwardTreatRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.treatType) {
      json["treatType"] = msg.treatType;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    if (msg.points) {
      json["points"] = msg.points;
    }
    if (msg.imageUrl) {
      json["imageUrl"] = msg.imageUrl;
    }
    if (msg.awardedBy) {
      json["awardedBy"] = msg.awardedBy;
    }
    if (msg.applicationId) {
      json["applicationId"] = msg.applicationId;
    }
    if (msg.metadata) {
      const _metadata_ = Object.fromEntries(
        Object.entries(msg.metadata)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(AwardTreatRequestJSON.Metadata._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_metadata_).length > 0) {
        json["metadata"] = _metadata_;
      }
    }
    if (msg.expiresAt && (msg.expiresAt.seconds || msg.expiresAt.nanos)) {
      json["expiresAt"] = protoscript.serializeTimestamp(msg.expiresAt);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: AwardTreatRequest,
    json: any,
  ): AwardTreatRequest {
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _treatType_ = json["treatType"] ?? json["treat_type"];
    if (_treatType_) {
      msg.treatType = _treatType_;
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _points_ = json["points"];
    if (_points_) {
      msg.points = protoscript.parseNumber(_points_);
    }
    const _imageUrl_ = json["imageUrl"] ?? json["image_url"];
    if (_imageUrl_) {
      msg.imageUrl = _imageUrl_;
    }
    const _awardedBy_ = json["awardedBy"] ?? json["awarded_by"];
    if (_awardedBy_) {
      msg.awardedBy = _awardedBy_;
    }
    const _applicationId_ = json["applicationId"] ?? json["application_id"];
    if (_applicationId_) {
      msg.applicationId = _applicationId_;
    }
    const _metadata_ = json["metadata"];
    if (_metadata_) {
      msg.metadata = Object.fromEntries(
        Object.entries(_metadata_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(AwardTreatRequestJSON.Metadata._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _expiresAt_ = json["expiresAt"] ?? json["expires_at"];
    if (_expiresAt_) {
      msg.expiresAt = protoscript.parseTimestamp(_expiresAt_);
    }
    return msg;
  },

  Metadata: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<AwardTreatRequest.Metadata>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: AwardTreatRequest.Metadata,
      json: any,
    ): AwardTreatRequest.Metadata {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TreatResponseJSON = {
  /**
   * Serializes TreatResponse to JSON.
   */
  encode: function (msg: PartialDeep<TreatResponse>): string {
    return JSON.stringify(TreatResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes TreatResponse from JSON.
   */
  decode: function (json: string): TreatResponse {
    return TreatResponseJSON._readMessage(
      TreatResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TreatResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TreatResponse>): TreatResponse {
    return {
      status: common.ResponseStatusJSON.initialize(),
      treat: TreatJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TreatResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.status) {
      const _status_ = common.ResponseStatusJSON._writeMessage(msg.status);
      if (Object.keys(_status_).length > 0) {
        json["status"] = _status_;
      }
    }
    if (msg.treat) {
      const _treat_ = TreatJSON._writeMessage(msg.treat);
      if (Object.keys(_treat_).length > 0) {
        json["treat"] = _treat_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TreatResponse, json: any): TreatResponse {
    const _status_ = json["status"];
    if (_status_) {
      common.ResponseStatusJSON._readMessage(msg.status, _status_);
    }
    const _treat_ = json["treat"];
    if (_treat_) {
      TreatJSON._readMessage(msg.treat, _treat_);
    }
    return msg;
  },
};

export const GetTreatRequestJSON = {
  /**
   * Serializes GetTreatRequest to JSON.
   */
  encode: function (msg: PartialDeep<GetTreatRequest>): string {
    return JSON.stringify(GetTreatRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetTreatRequest from JSON.
   */
  decode: function (json: string): GetTreatRequest {
    return GetTreatRequestJSON._readMessage(
      GetTreatRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GetTreatRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetTreatRequest>): GetTreatRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetTreatRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: GetTreatRequest, json: any): GetTreatRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    return msg;
  },
};

export const UpdateTreatRequestJSON = {
  /**
   * Serializes UpdateTreatRequest to JSON.
   */
  encode: function (msg: PartialDeep<UpdateTreatRequest>): string {
    return JSON.stringify(UpdateTreatRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes UpdateTreatRequest from JSON.
   */
  decode: function (json: string): UpdateTreatRequest {
    return UpdateTreatRequestJSON._readMessage(
      UpdateTreatRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes UpdateTreatRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<UpdateTreatRequest>): UpdateTreatRequest {
    return {
      id: "",
      title: "",
      description: "",
      points: 0,
      imageUrl: "",
      metadata: {},
      expiresAt: protoscript.TimestampJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UpdateTreatRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.title) {
      json["title"] = msg.title;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    if (msg.points) {
      json["points"] = msg.points;
    }
    if (msg.imageUrl) {
      json["imageUrl"] = msg.imageUrl;
    }
    if (msg.metadata) {
      const _metadata_ = Object.fromEntries(
        Object.entries(msg.metadata)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(UpdateTreatRequestJSON.Metadata._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_metadata_).length > 0) {
        json["metadata"] = _metadata_;
      }
    }
    if (msg.expiresAt && (msg.expiresAt.seconds || msg.expiresAt.nanos)) {
      json["expiresAt"] = protoscript.serializeTimestamp(msg.expiresAt);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UpdateTreatRequest,
    json: any,
  ): UpdateTreatRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _title_ = json["title"];
    if (_title_) {
      msg.title = _title_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _points_ = json["points"];
    if (_points_) {
      msg.points = protoscript.parseNumber(_points_);
    }
    const _imageUrl_ = json["imageUrl"] ?? json["image_url"];
    if (_imageUrl_) {
      msg.imageUrl = _imageUrl_;
    }
    const _metadata_ = json["metadata"];
    if (_metadata_) {
      msg.metadata = Object.fromEntries(
        Object.entries(_metadata_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(UpdateTreatRequestJSON.Metadata._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _expiresAt_ = json["expiresAt"] ?? json["expires_at"];
    if (_expiresAt_) {
      msg.expiresAt = protoscript.parseTimestamp(_expiresAt_);
    }
    return msg;
  },

  Metadata: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<UpdateTreatRequest.Metadata>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: UpdateTreatRequest.Metadata,
      json: any,
    ): UpdateTreatRequest.Metadata {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const DeleteTreatRequestJSON = {
  /**
   * Serializes DeleteTreatRequest to JSON.
   */
  encode: function (msg: PartialDeep<DeleteTreatRequest>): string {
    return JSON.stringify(DeleteTreatRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes DeleteTreatRequest from JSON.
   */
  decode: function (json: string): DeleteTreatRequest {
    return DeleteTreatRequestJSON._readMessage(
      DeleteTreatRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes DeleteTreatRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<DeleteTreatRequest>): DeleteTreatRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DeleteTreatRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DeleteTreatRequest,
    json: any,
  ): DeleteTreatRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    return msg;
  },
};

export const ListTreatsRequestJSON = {
  /**
   * Serializes ListTreatsRequest to JSON.
   */
  encode: function (msg: PartialDeep<ListTreatsRequest>): string {
    return JSON.stringify(ListTreatsRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListTreatsRequest from JSON.
   */
  decode: function (json: string): ListTreatsRequest {
    return ListTreatsRequestJSON._readMessage(
      ListTreatsRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListTreatsRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListTreatsRequest>): ListTreatsRequest {
    return {
      userId: "",
      treatType: "",
      applicationId: "",
      fromDate: protoscript.TimestampJSON.initialize(),
      toDate: protoscript.TimestampJSON.initialize(),
      includeExpired: false,
      minPoints: 0,
      maxPoints: 0,
      page: 0,
      pageSize: 0,
      sortBy: "",
      sortDesc: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTreatsRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.treatType) {
      json["treatType"] = msg.treatType;
    }
    if (msg.applicationId) {
      json["applicationId"] = msg.applicationId;
    }
    if (msg.fromDate && (msg.fromDate.seconds || msg.fromDate.nanos)) {
      json["fromDate"] = protoscript.serializeTimestamp(msg.fromDate);
    }
    if (msg.toDate && (msg.toDate.seconds || msg.toDate.nanos)) {
      json["toDate"] = protoscript.serializeTimestamp(msg.toDate);
    }
    if (msg.includeExpired) {
      json["includeExpired"] = msg.includeExpired;
    }
    if (msg.minPoints) {
      json["minPoints"] = msg.minPoints;
    }
    if (msg.maxPoints) {
      json["maxPoints"] = msg.maxPoints;
    }
    if (msg.page) {
      json["page"] = msg.page;
    }
    if (msg.pageSize) {
      json["pageSize"] = msg.pageSize;
    }
    if (msg.sortBy) {
      json["sortBy"] = msg.sortBy;
    }
    if (msg.sortDesc) {
      json["sortDesc"] = msg.sortDesc;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTreatsRequest,
    json: any,
  ): ListTreatsRequest {
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _treatType_ = json["treatType"] ?? json["treat_type"];
    if (_treatType_) {
      msg.treatType = _treatType_;
    }
    const _applicationId_ = json["applicationId"] ?? json["application_id"];
    if (_applicationId_) {
      msg.applicationId = _applicationId_;
    }
    const _fromDate_ = json["fromDate"] ?? json["from_date"];
    if (_fromDate_) {
      msg.fromDate = protoscript.parseTimestamp(_fromDate_);
    }
    const _toDate_ = json["toDate"] ?? json["to_date"];
    if (_toDate_) {
      msg.toDate = protoscript.parseTimestamp(_toDate_);
    }
    const _includeExpired_ = json["includeExpired"] ?? json["include_expired"];
    if (_includeExpired_) {
      msg.includeExpired = _includeExpired_;
    }
    const _minPoints_ = json["minPoints"] ?? json["min_points"];
    if (_minPoints_) {
      msg.minPoints = protoscript.parseNumber(_minPoints_);
    }
    const _maxPoints_ = json["maxPoints"] ?? json["max_points"];
    if (_maxPoints_) {
      msg.maxPoints = protoscript.parseNumber(_maxPoints_);
    }
    const _page_ = json["page"];
    if (_page_) {
      msg.page = protoscript.parseNumber(_page_);
    }
    const _pageSize_ = json["pageSize"] ?? json["page_size"];
    if (_pageSize_) {
      msg.pageSize = protoscript.parseNumber(_pageSize_);
    }
    const _sortBy_ = json["sortBy"] ?? json["sort_by"];
    if (_sortBy_) {
      msg.sortBy = _sortBy_;
    }
    const _sortDesc_ = json["sortDesc"] ?? json["sort_desc"];
    if (_sortDesc_) {
      msg.sortDesc = _sortDesc_;
    }
    return msg;
  },
};

export const ListTreatsResponseJSON = {
  /**
   * Serializes ListTreatsResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListTreatsResponse>): string {
    return JSON.stringify(ListTreatsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListTreatsResponse from JSON.
   */
  decode: function (json: string): ListTreatsResponse {
    return ListTreatsResponseJSON._readMessage(
      ListTreatsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListTreatsResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ListTreatsResponse>): ListTreatsResponse {
    return {
      status: common.ResponseStatusJSON.initialize(),
      treats: [],
      totalCount: 0,
      page: 0,
      pageSize: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListTreatsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.status) {
      const _status_ = common.ResponseStatusJSON._writeMessage(msg.status);
      if (Object.keys(_status_).length > 0) {
        json["status"] = _status_;
      }
    }
    if (msg.treats?.length) {
      json["treats"] = msg.treats.map(TreatJSON._writeMessage);
    }
    if (msg.totalCount) {
      json["totalCount"] = msg.totalCount;
    }
    if (msg.page) {
      json["page"] = msg.page;
    }
    if (msg.pageSize) {
      json["pageSize"] = msg.pageSize;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListTreatsResponse,
    json: any,
  ): ListTreatsResponse {
    const _status_ = json["status"];
    if (_status_) {
      common.ResponseStatusJSON._readMessage(msg.status, _status_);
    }
    const _treats_ = json["treats"];
    if (_treats_) {
      for (const item of _treats_) {
        const m = TreatJSON.initialize();
        TreatJSON._readMessage(m, item);
        msg.treats.push(m);
      }
    }
    const _totalCount_ = json["totalCount"] ?? json["total_count"];
    if (_totalCount_) {
      msg.totalCount = protoscript.parseNumber(_totalCount_);
    }
    const _page_ = json["page"];
    if (_page_) {
      msg.page = protoscript.parseNumber(_page_);
    }
    const _pageSize_ = json["pageSize"] ?? json["page_size"];
    if (_pageSize_) {
      msg.pageSize = protoscript.parseNumber(_pageSize_);
    }
    return msg;
  },
};

export const GetUserTreatsSummaryRequestJSON = {
  /**
   * Serializes GetUserTreatsSummaryRequest to JSON.
   */
  encode: function (msg: PartialDeep<GetUserTreatsSummaryRequest>): string {
    return JSON.stringify(GetUserTreatsSummaryRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetUserTreatsSummaryRequest from JSON.
   */
  decode: function (json: string): GetUserTreatsSummaryRequest {
    return GetUserTreatsSummaryRequestJSON._readMessage(
      GetUserTreatsSummaryRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GetUserTreatsSummaryRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetUserTreatsSummaryRequest>,
  ): GetUserTreatsSummaryRequest {
    return {
      userId: "",
      applicationId: "",
      fromDate: protoscript.TimestampJSON.initialize(),
      toDate: protoscript.TimestampJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetUserTreatsSummaryRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.applicationId) {
      json["applicationId"] = msg.applicationId;
    }
    if (msg.fromDate && (msg.fromDate.seconds || msg.fromDate.nanos)) {
      json["fromDate"] = protoscript.serializeTimestamp(msg.fromDate);
    }
    if (msg.toDate && (msg.toDate.seconds || msg.toDate.nanos)) {
      json["toDate"] = protoscript.serializeTimestamp(msg.toDate);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetUserTreatsSummaryRequest,
    json: any,
  ): GetUserTreatsSummaryRequest {
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _applicationId_ = json["applicationId"] ?? json["application_id"];
    if (_applicationId_) {
      msg.applicationId = _applicationId_;
    }
    const _fromDate_ = json["fromDate"] ?? json["from_date"];
    if (_fromDate_) {
      msg.fromDate = protoscript.parseTimestamp(_fromDate_);
    }
    const _toDate_ = json["toDate"] ?? json["to_date"];
    if (_toDate_) {
      msg.toDate = protoscript.parseTimestamp(_toDate_);
    }
    return msg;
  },
};

export const TreatsSummaryJSON = {
  /**
   * Serializes TreatsSummary to JSON.
   */
  encode: function (msg: PartialDeep<TreatsSummary>): string {
    return JSON.stringify(TreatsSummaryJSON._writeMessage(msg));
  },

  /**
   * Deserializes TreatsSummary from JSON.
   */
  decode: function (json: string): TreatsSummary {
    return TreatsSummaryJSON._readMessage(
      TreatsSummaryJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TreatsSummary with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TreatsSummary>): TreatsSummary {
    return {
      userId: "",
      totalTreats: 0,
      totalPoints: 0,
      pointsByType: {},
      recentTreats: [],
      fromDate: protoscript.TimestampJSON.initialize(),
      toDate: protoscript.TimestampJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TreatsSummary>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.userId) {
      json["userId"] = msg.userId;
    }
    if (msg.totalTreats) {
      json["totalTreats"] = msg.totalTreats;
    }
    if (msg.totalPoints) {
      json["totalPoints"] = msg.totalPoints;
    }
    if (msg.pointsByType) {
      const _pointsByType_ = Object.fromEntries(
        Object.entries(msg.pointsByType)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TreatsSummaryJSON.PointsByType._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_pointsByType_).length > 0) {
        json["pointsByType"] = _pointsByType_;
      }
    }
    if (msg.recentTreats?.length) {
      json["recentTreats"] = msg.recentTreats.map(TreatJSON._writeMessage);
    }
    if (msg.fromDate && (msg.fromDate.seconds || msg.fromDate.nanos)) {
      json["fromDate"] = protoscript.serializeTimestamp(msg.fromDate);
    }
    if (msg.toDate && (msg.toDate.seconds || msg.toDate.nanos)) {
      json["toDate"] = protoscript.serializeTimestamp(msg.toDate);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TreatsSummary, json: any): TreatsSummary {
    const _userId_ = json["userId"] ?? json["user_id"];
    if (_userId_) {
      msg.userId = _userId_;
    }
    const _totalTreats_ = json["totalTreats"] ?? json["total_treats"];
    if (_totalTreats_) {
      msg.totalTreats = protoscript.parseNumber(_totalTreats_);
    }
    const _totalPoints_ = json["totalPoints"] ?? json["total_points"];
    if (_totalPoints_) {
      msg.totalPoints = protoscript.parseNumber(_totalPoints_);
    }
    const _pointsByType_ = json["pointsByType"] ?? json["points_by_type"];
    if (_pointsByType_) {
      msg.pointsByType = Object.fromEntries(
        Object.entries(_pointsByType_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TreatsSummaryJSON.PointsByType._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _recentTreats_ = json["recentTreats"] ?? json["recent_treats"];
    if (_recentTreats_) {
      for (const item of _recentTreats_) {
        const m = TreatJSON.initialize();
        TreatJSON._readMessage(m, item);
        msg.recentTreats.push(m);
      }
    }
    const _fromDate_ = json["fromDate"] ?? json["from_date"];
    if (_fromDate_) {
      msg.fromDate = protoscript.parseTimestamp(_fromDate_);
    }
    const _toDate_ = json["toDate"] ?? json["to_date"];
    if (_toDate_) {
      msg.toDate = protoscript.parseTimestamp(_toDate_);
    }
    return msg;
  },

  PointsByType: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TreatsSummary.PointsByType>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TreatsSummary.PointsByType,
      json: any,
    ): TreatsSummary.PointsByType {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = protoscript.parseNumber(_value_);
      }
      return msg;
    },
  },
};

export const TreatsSummaryResponseJSON = {
  /**
   * Serializes TreatsSummaryResponse to JSON.
   */
  encode: function (msg: PartialDeep<TreatsSummaryResponse>): string {
    return JSON.stringify(TreatsSummaryResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes TreatsSummaryResponse from JSON.
   */
  decode: function (json: string): TreatsSummaryResponse {
    return TreatsSummaryResponseJSON._readMessage(
      TreatsSummaryResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TreatsSummaryResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<TreatsSummaryResponse>,
  ): TreatsSummaryResponse {
    return {
      status: common.ResponseStatusJSON.initialize(),
      summary: TreatsSummaryJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TreatsSummaryResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.status) {
      const _status_ = common.ResponseStatusJSON._writeMessage(msg.status);
      if (Object.keys(_status_).length > 0) {
        json["status"] = _status_;
      }
    }
    if (msg.summary) {
      const _summary_ = TreatsSummaryJSON._writeMessage(msg.summary);
      if (Object.keys(_summary_).length > 0) {
        json["summary"] = _summary_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TreatsSummaryResponse,
    json: any,
  ): TreatsSummaryResponse {
    const _status_ = json["status"];
    if (_status_) {
      common.ResponseStatusJSON._readMessage(msg.status, _status_);
    }
    const _summary_ = json["summary"];
    if (_summary_) {
      TreatsSummaryJSON._readMessage(msg.summary, _summary_);
    }
    return msg;
  },
};

export const GetTreatStatsRequestJSON = {
  /**
   * Serializes GetTreatStatsRequest to JSON.
   */
  encode: function (msg: PartialDeep<GetTreatStatsRequest>): string {
    return JSON.stringify(GetTreatStatsRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetTreatStatsRequest from JSON.
   */
  decode: function (json: string): GetTreatStatsRequest {
    return GetTreatStatsRequestJSON._readMessage(
      GetTreatStatsRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GetTreatStatsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetTreatStatsRequest>,
  ): GetTreatStatsRequest {
    return {
      applicationId: "",
      fromDate: protoscript.TimestampJSON.initialize(),
      toDate: protoscript.TimestampJSON.initialize(),
      groupBy: "",
      userIds: [],
      treatTypes: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetTreatStatsRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.applicationId) {
      json["applicationId"] = msg.applicationId;
    }
    if (msg.fromDate && (msg.fromDate.seconds || msg.fromDate.nanos)) {
      json["fromDate"] = protoscript.serializeTimestamp(msg.fromDate);
    }
    if (msg.toDate && (msg.toDate.seconds || msg.toDate.nanos)) {
      json["toDate"] = protoscript.serializeTimestamp(msg.toDate);
    }
    if (msg.groupBy) {
      json["groupBy"] = msg.groupBy;
    }
    if (msg.userIds?.length) {
      json["userIds"] = msg.userIds;
    }
    if (msg.treatTypes?.length) {
      json["treatTypes"] = msg.treatTypes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetTreatStatsRequest,
    json: any,
  ): GetTreatStatsRequest {
    const _applicationId_ = json["applicationId"] ?? json["application_id"];
    if (_applicationId_) {
      msg.applicationId = _applicationId_;
    }
    const _fromDate_ = json["fromDate"] ?? json["from_date"];
    if (_fromDate_) {
      msg.fromDate = protoscript.parseTimestamp(_fromDate_);
    }
    const _toDate_ = json["toDate"] ?? json["to_date"];
    if (_toDate_) {
      msg.toDate = protoscript.parseTimestamp(_toDate_);
    }
    const _groupBy_ = json["groupBy"] ?? json["group_by"];
    if (_groupBy_) {
      msg.groupBy = _groupBy_;
    }
    const _userIds_ = json["userIds"] ?? json["user_ids"];
    if (_userIds_) {
      msg.userIds = _userIds_;
    }
    const _treatTypes_ = json["treatTypes"] ?? json["treat_types"];
    if (_treatTypes_) {
      msg.treatTypes = _treatTypes_;
    }
    return msg;
  },
};

export const TreatStatsJSON = {
  /**
   * Serializes TreatStats to JSON.
   */
  encode: function (msg: PartialDeep<TreatStats>): string {
    return JSON.stringify(TreatStatsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TreatStats from JSON.
   */
  decode: function (json: string): TreatStats {
    return TreatStatsJSON._readMessage(
      TreatStatsJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TreatStats with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TreatStats>): TreatStats {
    return {
      dataPoints: [],
      totalTreats: 0,
      totalPoints: 0,
      uniqueUsers: 0,
      pointsByType: {},
      fromDate: protoscript.TimestampJSON.initialize(),
      toDate: protoscript.TimestampJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TreatStats>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.dataPoints?.length) {
      json["dataPoints"] = msg.dataPoints.map(
        TreatStatsJSON.DataPoint._writeMessage,
      );
    }
    if (msg.totalTreats) {
      json["totalTreats"] = msg.totalTreats;
    }
    if (msg.totalPoints) {
      json["totalPoints"] = msg.totalPoints;
    }
    if (msg.uniqueUsers) {
      json["uniqueUsers"] = msg.uniqueUsers;
    }
    if (msg.pointsByType) {
      const _pointsByType_ = Object.fromEntries(
        Object.entries(msg.pointsByType)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TreatStatsJSON.PointsByType._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_pointsByType_).length > 0) {
        json["pointsByType"] = _pointsByType_;
      }
    }
    if (msg.fromDate && (msg.fromDate.seconds || msg.fromDate.nanos)) {
      json["fromDate"] = protoscript.serializeTimestamp(msg.fromDate);
    }
    if (msg.toDate && (msg.toDate.seconds || msg.toDate.nanos)) {
      json["toDate"] = protoscript.serializeTimestamp(msg.toDate);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TreatStats, json: any): TreatStats {
    const _dataPoints_ = json["dataPoints"] ?? json["data_points"];
    if (_dataPoints_) {
      for (const item of _dataPoints_) {
        const m = TreatStatsJSON.DataPoint.initialize();
        TreatStatsJSON.DataPoint._readMessage(m, item);
        msg.dataPoints.push(m);
      }
    }
    const _totalTreats_ = json["totalTreats"] ?? json["total_treats"];
    if (_totalTreats_) {
      msg.totalTreats = protoscript.parseNumber(_totalTreats_);
    }
    const _totalPoints_ = json["totalPoints"] ?? json["total_points"];
    if (_totalPoints_) {
      msg.totalPoints = protoscript.parseNumber(_totalPoints_);
    }
    const _uniqueUsers_ = json["uniqueUsers"] ?? json["unique_users"];
    if (_uniqueUsers_) {
      msg.uniqueUsers = protoscript.parseNumber(_uniqueUsers_);
    }
    const _pointsByType_ = json["pointsByType"] ?? json["points_by_type"];
    if (_pointsByType_) {
      msg.pointsByType = Object.fromEntries(
        Object.entries(_pointsByType_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TreatStatsJSON.PointsByType._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _fromDate_ = json["fromDate"] ?? json["from_date"];
    if (_fromDate_) {
      msg.fromDate = protoscript.parseTimestamp(_fromDate_);
    }
    const _toDate_ = json["toDate"] ?? json["to_date"];
    if (_toDate_) {
      msg.toDate = protoscript.parseTimestamp(_toDate_);
    }
    return msg;
  },

  DataPoint: {
    /**
     * Serializes TreatStats.DataPoint to JSON.
     */
    encode: function (msg: PartialDeep<TreatStats.DataPoint>): string {
      return JSON.stringify(TreatStatsJSON.DataPoint._writeMessage(msg));
    },

    /**
     * Deserializes TreatStats.DataPoint from JSON.
     */
    decode: function (json: string): TreatStats.DataPoint {
      return TreatStatsJSON.DataPoint._readMessage(
        TreatStatsJSON.DataPoint.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TreatStats.DataPoint with all fields set to their default value.
     */
    initialize: function (
      msg?: Partial<TreatStats.DataPoint>,
    ): TreatStats.DataPoint {
      return {
        label: "",
        count: 0,
        totalPoints: 0,
        pointsByType: {},
        ...msg,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TreatStats.DataPoint>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.label) {
        json["label"] = msg.label;
      }
      if (msg.count) {
        json["count"] = msg.count;
      }
      if (msg.totalPoints) {
        json["totalPoints"] = msg.totalPoints;
      }
      if (msg.pointsByType) {
        const _pointsByType_ = Object.fromEntries(
          Object.entries(msg.pointsByType)
            .map(([key, value]) => ({ key: key as any, value: value as any }))
            .map(TreatStatsJSON.DataPoint.PointsByType._writeMessage)
            .map(({ key, value }) => [key, value]),
        );
        if (Object.keys(_pointsByType_).length > 0) {
          json["pointsByType"] = _pointsByType_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TreatStats.DataPoint,
      json: any,
    ): TreatStats.DataPoint {
      const _label_ = json["label"];
      if (_label_) {
        msg.label = _label_;
      }
      const _count_ = json["count"];
      if (_count_) {
        msg.count = protoscript.parseNumber(_count_);
      }
      const _totalPoints_ = json["totalPoints"] ?? json["total_points"];
      if (_totalPoints_) {
        msg.totalPoints = protoscript.parseNumber(_totalPoints_);
      }
      const _pointsByType_ = json["pointsByType"] ?? json["points_by_type"];
      if (_pointsByType_) {
        msg.pointsByType = Object.fromEntries(
          Object.entries(_pointsByType_)
            .map(([key, value]) => ({ key: key as any, value: value as any }))
            .map(TreatStatsJSON.DataPoint.PointsByType._readMessage)
            .map(({ key, value }) => [key, value]),
        );
      }
      return msg;
    },

    PointsByType: {
      /**
       * @private
       */
      _writeMessage: function (
        msg: PartialDeep<TreatStats.DataPoint.PointsByType>,
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.key) {
          json["key"] = msg.key;
        }
        if (msg.value) {
          json["value"] = msg.value;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TreatStats.DataPoint.PointsByType,
        json: any,
      ): TreatStats.DataPoint.PointsByType {
        const _key_ = json["key"];
        if (_key_) {
          msg.key = _key_;
        }
        const _value_ = json["value"];
        if (_value_) {
          msg.value = protoscript.parseNumber(_value_);
        }
        return msg;
      },
    },
  },

  PointsByType: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TreatStats.PointsByType>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TreatStats.PointsByType,
      json: any,
    ): TreatStats.PointsByType {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = protoscript.parseNumber(_value_);
      }
      return msg;
    },
  },
};

export const TreatStatsResponseJSON = {
  /**
   * Serializes TreatStatsResponse to JSON.
   */
  encode: function (msg: PartialDeep<TreatStatsResponse>): string {
    return JSON.stringify(TreatStatsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes TreatStatsResponse from JSON.
   */
  decode: function (json: string): TreatStatsResponse {
    return TreatStatsResponseJSON._readMessage(
      TreatStatsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TreatStatsResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TreatStatsResponse>): TreatStatsResponse {
    return {
      status: common.ResponseStatusJSON.initialize(),
      stats: TreatStatsJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TreatStatsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.status) {
      const _status_ = common.ResponseStatusJSON._writeMessage(msg.status);
      if (Object.keys(_status_).length > 0) {
        json["status"] = _status_;
      }
    }
    if (msg.stats) {
      const _stats_ = TreatStatsJSON._writeMessage(msg.stats);
      if (Object.keys(_stats_).length > 0) {
        json["stats"] = _stats_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TreatStatsResponse,
    json: any,
  ): TreatStatsResponse {
    const _status_ = json["status"];
    if (_status_) {
      common.ResponseStatusJSON._readMessage(msg.status, _status_);
    }
    const _stats_ = json["stats"];
    if (_stats_) {
      TreatStatsJSON._readMessage(msg.stats, _stats_);
    }
    return msg;
  },
};
