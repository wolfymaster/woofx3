// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: workflow.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as common from "./common.pb";

//========================================//
//                 Types                  //
//========================================//

/**
 * Workflow definition
 */
export interface Workflow {
  id: string;
  name: string;
  description: string;
  applicationId: string;
  createdBy: string;
  enabled: boolean;
  steps: WorkflowStep[];
  variables: Record<string, Workflow.Variables["value"] | undefined>;
  onSuccess: string;
  onFailure: string;
  maxRetries: number;
  timeoutSeconds: number;
  createdAt: protoscript.Timestamp;
  updatedAt: protoscript.Timestamp;
}

export declare namespace Workflow {
  interface Variables {
    key: string;
    value: string;
  }
}

/**
 * A single step in a workflow
 */
export interface WorkflowStep {
  id: string;
  name: string;
  description: string;
  type: string;
  parameters: Record<string, WorkflowStep.Parameters["value"] | undefined>;
  onSuccess: string;
  onFailure: string;
  timeoutSeconds: number;
  retryAttempts: number;
  async: boolean;
  outputs: Record<string, WorkflowStep.Outputs["value"] | undefined>;
}

export declare namespace WorkflowStep {
  interface Parameters {
    key: string;
    value: string;
  }

  interface Outputs {
    key: string;
    value: string;
  }
}

/**
 * Workflow execution
 */
export interface WorkflowExecution {
  id: string;
  workflowId: string;
  status: string;
  startedBy: string;
  applicationId: string;
  inputs: Record<string, WorkflowExecution.Inputs["value"] | undefined>;
  outputs: Record<string, WorkflowExecution.Outputs["value"] | undefined>;
  error: string;
  startedAt: protoscript.Timestamp;
  completedAt: protoscript.Timestamp;
  createdAt: protoscript.Timestamp;
  updatedAt: protoscript.Timestamp;
  steps: ExecutionStep[];
}

export declare namespace WorkflowExecution {
  interface Inputs {
    key: string;
    value: string;
  }

  interface Outputs {
    key: string;
    value: string;
  }
}

/**
 * Execution details for a single step
 */
export interface ExecutionStep {
  stepId: string;
  name: string;
  status: string;
  attempt: number;
  error: string;
  inputs: Record<string, ExecutionStep.Inputs["value"] | undefined>;
  outputs: Record<string, ExecutionStep.Outputs["value"] | undefined>;
  startedAt: protoscript.Timestamp;
  completedAt: protoscript.Timestamp;
  durationMs: bigint;
}

export declare namespace ExecutionStep {
  interface Inputs {
    key: string;
    value: string;
  }

  interface Outputs {
    key: string;
    value: string;
  }
}

/**
 * Request to create a new workflow
 */
export interface CreateWorkflowRequest {
  name: string;
  description: string;
  applicationId: string;
  createdBy: string;
  enabled: boolean;
  steps: WorkflowStep[];
  variables: Record<
    string,
    CreateWorkflowRequest.Variables["value"] | undefined
  >;
  onSuccess: string;
  onFailure: string;
  maxRetries: number;
  timeoutSeconds: number;
}

export declare namespace CreateWorkflowRequest {
  interface Variables {
    key: string;
    value: string;
  }
}

/**
 * Request to get a workflow by ID
 */
export interface GetWorkflowRequest {
  id: string;
}

/**
 * Response containing a single workflow
 */
export interface WorkflowResponse {
  status: common.ResponseStatus;
  workflow: Workflow;
}

/**
 * Request to update an existing workflow
 */
export interface UpdateWorkflowRequest {
  id: string;
  name: string;
  description: string;
  enabled: boolean;
  steps: WorkflowStep[];
  variables: Record<
    string,
    UpdateWorkflowRequest.Variables["value"] | undefined
  >;
  onSuccess: string;
  onFailure: string;
  maxRetries: number;
  timeoutSeconds: number;
}

export declare namespace UpdateWorkflowRequest {
  interface Variables {
    key: string;
    value: string;
  }
}

/**
 * Request to delete a workflow
 */
export interface DeleteWorkflowRequest {
  id: string;
}

/**
 * Request to list workflows
 */
export interface ListWorkflowsRequest {
  applicationId: string;
  includeDisabled: boolean;
  page: number;
  pageSize: number;
  sortBy: string;
  sortDesc: boolean;
}

/**
 * Response containing a list of workflows
 */
export interface ListWorkflowsResponse {
  status: common.ResponseStatus;
  workflows: Workflow[];
  totalCount: number;
  page: number;
  pageSize: number;
}

/**
 * Request to execute a workflow
 */
export interface ExecuteWorkflowRequest {
  workflowId: string;
  applicationId: string;
  startedBy: string;
  inputs: Record<string, ExecuteWorkflowRequest.Inputs["value"] | undefined>;
  async: boolean;
  correlationId: string;
}

export declare namespace ExecuteWorkflowRequest {
  interface Inputs {
    key: string;
    value: string;
  }
}

/**
 * Response from executing a workflow
 */
export interface ExecuteWorkflowResponse {
  status: common.ResponseStatus;
  executionId: string;
  async: boolean;
  statusUrl: string;
  outputs: Record<string, ExecuteWorkflowResponse.Outputs["value"] | undefined>;
}

export declare namespace ExecuteWorkflowResponse {
  interface Outputs {
    key: string;
    value: string;
  }
}

/**
 * Request to get a workflow execution
 */
export interface GetWorkflowExecutionRequest {
  id: string;
}

/**
 * Response containing workflow execution details
 */
export interface WorkflowExecutionResponse {
  status: common.ResponseStatus;
  execution: WorkflowExecution;
}

/**
 * Request to list workflow executions
 */
export interface ListWorkflowExecutionsRequest {
  workflowId: string;
  applicationId: string;
  status: string;
  startedBy: string;
  from: protoscript.Timestamp;
  to: protoscript.Timestamp;
  page: number;
  pageSize: number;
  sortBy: string;
  sortDesc: boolean;
}

/**
 * Response containing a list of workflow executions
 */
export interface ListWorkflowExecutionsResponse {
  status: common.ResponseStatus;
  executions: WorkflowExecution[];
  totalCount: number;
  page: number;
  pageSize: number;
}

/**
 * Request to cancel a workflow execution
 */
export interface CancelWorkflowExecutionRequest {
  id: string;
  reason: string;
}

//========================================//
//    WorkflowService Protobuf Client     //
//========================================//

/**
 * Create a new workflow definition
 */
export async function CreateWorkflow(
  createWorkflowRequest: CreateWorkflowRequest,
  config?: ClientConfiguration,
): Promise<WorkflowResponse> {
  const response = await PBrequest(
    "/workflow.WorkflowService/CreateWorkflow",
    CreateWorkflowRequest.encode(createWorkflowRequest),
    config,
  );
  return WorkflowResponse.decode(response);
}

/**
 * Get a workflow by ID
 */
export async function GetWorkflow(
  getWorkflowRequest: GetWorkflowRequest,
  config?: ClientConfiguration,
): Promise<WorkflowResponse> {
  const response = await PBrequest(
    "/workflow.WorkflowService/GetWorkflow",
    GetWorkflowRequest.encode(getWorkflowRequest),
    config,
  );
  return WorkflowResponse.decode(response);
}

/**
 * Update an existing workflow
 */
export async function UpdateWorkflow(
  updateWorkflowRequest: UpdateWorkflowRequest,
  config?: ClientConfiguration,
): Promise<WorkflowResponse> {
  const response = await PBrequest(
    "/workflow.WorkflowService/UpdateWorkflow",
    UpdateWorkflowRequest.encode(updateWorkflowRequest),
    config,
  );
  return WorkflowResponse.decode(response);
}

/**
 * Delete a workflow
 */
export async function DeleteWorkflow(
  deleteWorkflowRequest: DeleteWorkflowRequest,
  config?: ClientConfiguration,
): Promise<common.ResponseStatus> {
  const response = await PBrequest(
    "/workflow.WorkflowService/DeleteWorkflow",
    DeleteWorkflowRequest.encode(deleteWorkflowRequest),
    config,
  );
  return common.ResponseStatus.decode(response);
}

/**
 * List workflows with optional filtering
 */
export async function ListWorkflows(
  listWorkflowsRequest: ListWorkflowsRequest,
  config?: ClientConfiguration,
): Promise<ListWorkflowsResponse> {
  const response = await PBrequest(
    "/workflow.WorkflowService/ListWorkflows",
    ListWorkflowsRequest.encode(listWorkflowsRequest),
    config,
  );
  return ListWorkflowsResponse.decode(response);
}

/**
 * Execute a workflow
 */
export async function ExecuteWorkflow(
  executeWorkflowRequest: ExecuteWorkflowRequest,
  config?: ClientConfiguration,
): Promise<ExecuteWorkflowResponse> {
  const response = await PBrequest(
    "/workflow.WorkflowService/ExecuteWorkflow",
    ExecuteWorkflowRequest.encode(executeWorkflowRequest),
    config,
  );
  return ExecuteWorkflowResponse.decode(response);
}

/**
 * Get workflow execution status
 */
export async function GetWorkflowExecution(
  getWorkflowExecutionRequest: GetWorkflowExecutionRequest,
  config?: ClientConfiguration,
): Promise<WorkflowExecutionResponse> {
  const response = await PBrequest(
    "/workflow.WorkflowService/GetWorkflowExecution",
    GetWorkflowExecutionRequest.encode(getWorkflowExecutionRequest),
    config,
  );
  return WorkflowExecutionResponse.decode(response);
}

/**
 * List workflow executions
 */
export async function ListWorkflowExecutions(
  listWorkflowExecutionsRequest: ListWorkflowExecutionsRequest,
  config?: ClientConfiguration,
): Promise<ListWorkflowExecutionsResponse> {
  const response = await PBrequest(
    "/workflow.WorkflowService/ListWorkflowExecutions",
    ListWorkflowExecutionsRequest.encode(listWorkflowExecutionsRequest),
    config,
  );
  return ListWorkflowExecutionsResponse.decode(response);
}

/**
 * Cancel a running workflow execution
 */
export async function CancelWorkflowExecution(
  cancelWorkflowExecutionRequest: CancelWorkflowExecutionRequest,
  config?: ClientConfiguration,
): Promise<common.ResponseStatus> {
  const response = await PBrequest(
    "/workflow.WorkflowService/CancelWorkflowExecution",
    CancelWorkflowExecutionRequest.encode(cancelWorkflowExecutionRequest),
    config,
  );
  return common.ResponseStatus.decode(response);
}

//========================================//
//      WorkflowService JSON Client       //
//========================================//

/**
 * Create a new workflow definition
 */
export async function CreateWorkflowJSON(
  createWorkflowRequest: CreateWorkflowRequest,
  config?: ClientConfiguration,
): Promise<WorkflowResponse> {
  const response = await JSONrequest(
    "/workflow.WorkflowService/CreateWorkflow",
    CreateWorkflowRequestJSON.encode(createWorkflowRequest),
    config,
  );
  return WorkflowResponseJSON.decode(response);
}

/**
 * Get a workflow by ID
 */
export async function GetWorkflowJSON(
  getWorkflowRequest: GetWorkflowRequest,
  config?: ClientConfiguration,
): Promise<WorkflowResponse> {
  const response = await JSONrequest(
    "/workflow.WorkflowService/GetWorkflow",
    GetWorkflowRequestJSON.encode(getWorkflowRequest),
    config,
  );
  return WorkflowResponseJSON.decode(response);
}

/**
 * Update an existing workflow
 */
export async function UpdateWorkflowJSON(
  updateWorkflowRequest: UpdateWorkflowRequest,
  config?: ClientConfiguration,
): Promise<WorkflowResponse> {
  const response = await JSONrequest(
    "/workflow.WorkflowService/UpdateWorkflow",
    UpdateWorkflowRequestJSON.encode(updateWorkflowRequest),
    config,
  );
  return WorkflowResponseJSON.decode(response);
}

/**
 * Delete a workflow
 */
export async function DeleteWorkflowJSON(
  deleteWorkflowRequest: DeleteWorkflowRequest,
  config?: ClientConfiguration,
): Promise<common.ResponseStatus> {
  const response = await JSONrequest(
    "/workflow.WorkflowService/DeleteWorkflow",
    DeleteWorkflowRequestJSON.encode(deleteWorkflowRequest),
    config,
  );
  return common.ResponseStatusJSON.decode(response);
}

/**
 * List workflows with optional filtering
 */
export async function ListWorkflowsJSON(
  listWorkflowsRequest: ListWorkflowsRequest,
  config?: ClientConfiguration,
): Promise<ListWorkflowsResponse> {
  const response = await JSONrequest(
    "/workflow.WorkflowService/ListWorkflows",
    ListWorkflowsRequestJSON.encode(listWorkflowsRequest),
    config,
  );
  return ListWorkflowsResponseJSON.decode(response);
}

/**
 * Execute a workflow
 */
export async function ExecuteWorkflowJSON(
  executeWorkflowRequest: ExecuteWorkflowRequest,
  config?: ClientConfiguration,
): Promise<ExecuteWorkflowResponse> {
  const response = await JSONrequest(
    "/workflow.WorkflowService/ExecuteWorkflow",
    ExecuteWorkflowRequestJSON.encode(executeWorkflowRequest),
    config,
  );
  return ExecuteWorkflowResponseJSON.decode(response);
}

/**
 * Get workflow execution status
 */
export async function GetWorkflowExecutionJSON(
  getWorkflowExecutionRequest: GetWorkflowExecutionRequest,
  config?: ClientConfiguration,
): Promise<WorkflowExecutionResponse> {
  const response = await JSONrequest(
    "/workflow.WorkflowService/GetWorkflowExecution",
    GetWorkflowExecutionRequestJSON.encode(getWorkflowExecutionRequest),
    config,
  );
  return WorkflowExecutionResponseJSON.decode(response);
}

/**
 * List workflow executions
 */
export async function ListWorkflowExecutionsJSON(
  listWorkflowExecutionsRequest: ListWorkflowExecutionsRequest,
  config?: ClientConfiguration,
): Promise<ListWorkflowExecutionsResponse> {
  const response = await JSONrequest(
    "/workflow.WorkflowService/ListWorkflowExecutions",
    ListWorkflowExecutionsRequestJSON.encode(listWorkflowExecutionsRequest),
    config,
  );
  return ListWorkflowExecutionsResponseJSON.decode(response);
}

/**
 * Cancel a running workflow execution
 */
export async function CancelWorkflowExecutionJSON(
  cancelWorkflowExecutionRequest: CancelWorkflowExecutionRequest,
  config?: ClientConfiguration,
): Promise<common.ResponseStatus> {
  const response = await JSONrequest(
    "/workflow.WorkflowService/CancelWorkflowExecution",
    CancelWorkflowExecutionRequestJSON.encode(cancelWorkflowExecutionRequest),
    config,
  );
  return common.ResponseStatusJSON.decode(response);
}

//========================================//
//            WorkflowService             //
//========================================//

export interface WorkflowService<Context = unknown> {
  /**
   * Create a new workflow definition
   */
  CreateWorkflow: (
    createWorkflowRequest: CreateWorkflowRequest,
    context: Context,
  ) => Promise<WorkflowResponse> | WorkflowResponse;
  /**
   * Get a workflow by ID
   */
  GetWorkflow: (
    getWorkflowRequest: GetWorkflowRequest,
    context: Context,
  ) => Promise<WorkflowResponse> | WorkflowResponse;
  /**
   * Update an existing workflow
   */
  UpdateWorkflow: (
    updateWorkflowRequest: UpdateWorkflowRequest,
    context: Context,
  ) => Promise<WorkflowResponse> | WorkflowResponse;
  /**
   * Delete a workflow
   */
  DeleteWorkflow: (
    deleteWorkflowRequest: DeleteWorkflowRequest,
    context: Context,
  ) => Promise<common.ResponseStatus> | common.ResponseStatus;
  /**
   * List workflows with optional filtering
   */
  ListWorkflows: (
    listWorkflowsRequest: ListWorkflowsRequest,
    context: Context,
  ) => Promise<ListWorkflowsResponse> | ListWorkflowsResponse;
  /**
   * Execute a workflow
   */
  ExecuteWorkflow: (
    executeWorkflowRequest: ExecuteWorkflowRequest,
    context: Context,
  ) => Promise<ExecuteWorkflowResponse> | ExecuteWorkflowResponse;
  /**
   * Get workflow execution status
   */
  GetWorkflowExecution: (
    getWorkflowExecutionRequest: GetWorkflowExecutionRequest,
    context: Context,
  ) => Promise<WorkflowExecutionResponse> | WorkflowExecutionResponse;
  /**
   * List workflow executions
   */
  ListWorkflowExecutions: (
    listWorkflowExecutionsRequest: ListWorkflowExecutionsRequest,
    context: Context,
  ) => Promise<ListWorkflowExecutionsResponse> | ListWorkflowExecutionsResponse;
  /**
   * Cancel a running workflow execution
   */
  CancelWorkflowExecution: (
    cancelWorkflowExecutionRequest: CancelWorkflowExecutionRequest,
    context: Context,
  ) => Promise<common.ResponseStatus> | common.ResponseStatus;
}

export function createWorkflowService<Context>(
  service: WorkflowService<Context>,
) {
  return {
    name: "workflow.WorkflowService",
    methods: {
      CreateWorkflow: {
        name: "CreateWorkflow",
        handler: service.CreateWorkflow,
        input: {
          protobuf: CreateWorkflowRequest,
          json: CreateWorkflowRequestJSON,
        },
        output: { protobuf: WorkflowResponse, json: WorkflowResponseJSON },
      },
      GetWorkflow: {
        name: "GetWorkflow",
        handler: service.GetWorkflow,
        input: { protobuf: GetWorkflowRequest, json: GetWorkflowRequestJSON },
        output: { protobuf: WorkflowResponse, json: WorkflowResponseJSON },
      },
      UpdateWorkflow: {
        name: "UpdateWorkflow",
        handler: service.UpdateWorkflow,
        input: {
          protobuf: UpdateWorkflowRequest,
          json: UpdateWorkflowRequestJSON,
        },
        output: { protobuf: WorkflowResponse, json: WorkflowResponseJSON },
      },
      DeleteWorkflow: {
        name: "DeleteWorkflow",
        handler: service.DeleteWorkflow,
        input: {
          protobuf: DeleteWorkflowRequest,
          json: DeleteWorkflowRequestJSON,
        },
        output: {
          protobuf: common.ResponseStatus,
          json: common.ResponseStatusJSON,
        },
      },
      ListWorkflows: {
        name: "ListWorkflows",
        handler: service.ListWorkflows,
        input: {
          protobuf: ListWorkflowsRequest,
          json: ListWorkflowsRequestJSON,
        },
        output: {
          protobuf: ListWorkflowsResponse,
          json: ListWorkflowsResponseJSON,
        },
      },
      ExecuteWorkflow: {
        name: "ExecuteWorkflow",
        handler: service.ExecuteWorkflow,
        input: {
          protobuf: ExecuteWorkflowRequest,
          json: ExecuteWorkflowRequestJSON,
        },
        output: {
          protobuf: ExecuteWorkflowResponse,
          json: ExecuteWorkflowResponseJSON,
        },
      },
      GetWorkflowExecution: {
        name: "GetWorkflowExecution",
        handler: service.GetWorkflowExecution,
        input: {
          protobuf: GetWorkflowExecutionRequest,
          json: GetWorkflowExecutionRequestJSON,
        },
        output: {
          protobuf: WorkflowExecutionResponse,
          json: WorkflowExecutionResponseJSON,
        },
      },
      ListWorkflowExecutions: {
        name: "ListWorkflowExecutions",
        handler: service.ListWorkflowExecutions,
        input: {
          protobuf: ListWorkflowExecutionsRequest,
          json: ListWorkflowExecutionsRequestJSON,
        },
        output: {
          protobuf: ListWorkflowExecutionsResponse,
          json: ListWorkflowExecutionsResponseJSON,
        },
      },
      CancelWorkflowExecution: {
        name: "CancelWorkflowExecution",
        handler: service.CancelWorkflowExecution,
        input: {
          protobuf: CancelWorkflowExecutionRequest,
          json: CancelWorkflowExecutionRequestJSON,
        },
        output: {
          protobuf: common.ResponseStatus,
          json: common.ResponseStatusJSON,
        },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Workflow = {
  /**
   * Serializes Workflow to protobuf.
   */
  encode: function (msg: PartialDeep<Workflow>): Uint8Array {
    return Workflow._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Workflow from protobuf.
   */
  decode: function (bytes: ByteSource): Workflow {
    return Workflow._readMessage(
      Workflow.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Workflow with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Workflow>): Workflow {
    return {
      id: "",
      name: "",
      description: "",
      applicationId: "",
      createdBy: "",
      enabled: false,
      steps: [],
      variables: {},
      onSuccess: "",
      onFailure: "",
      maxRetries: 0,
      timeoutSeconds: 0,
      createdAt: protoscript.Timestamp.initialize(),
      updatedAt: protoscript.Timestamp.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Workflow>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.name) {
      writer.writeString(2, msg.name);
    }
    if (msg.description) {
      writer.writeString(3, msg.description);
    }
    if (msg.applicationId) {
      writer.writeString(4, msg.applicationId);
    }
    if (msg.createdBy) {
      writer.writeString(5, msg.createdBy);
    }
    if (msg.enabled) {
      writer.writeBool(6, msg.enabled);
    }
    if (msg.steps?.length) {
      writer.writeRepeatedMessage(
        7,
        msg.steps as any,
        WorkflowStep._writeMessage,
      );
    }
    if (msg.variables) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.variables).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        Workflow.Variables._writeMessage,
      );
    }
    if (msg.onSuccess) {
      writer.writeString(9, msg.onSuccess);
    }
    if (msg.onFailure) {
      writer.writeString(10, msg.onFailure);
    }
    if (msg.maxRetries) {
      writer.writeInt32(11, msg.maxRetries);
    }
    if (msg.timeoutSeconds) {
      writer.writeInt32(12, msg.timeoutSeconds);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        13,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.updatedAt) {
      writer.writeMessage(
        14,
        msg.updatedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Workflow,
    reader: protoscript.BinaryReader,
  ): Workflow {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.name = reader.readString();
          break;
        }
        case 3: {
          msg.description = reader.readString();
          break;
        }
        case 4: {
          msg.applicationId = reader.readString();
          break;
        }
        case 5: {
          msg.createdBy = reader.readString();
          break;
        }
        case 6: {
          msg.enabled = reader.readBool();
          break;
        }
        case 7: {
          const m = WorkflowStep.initialize();
          reader.readMessage(m, WorkflowStep._readMessage);
          msg.steps.push(m);
          break;
        }
        case 8: {
          const map = {} as Workflow.Variables;
          reader.readMessage(map, Workflow.Variables._readMessage);
          msg.variables[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          msg.onSuccess = reader.readString();
          break;
        }
        case 10: {
          msg.onFailure = reader.readString();
          break;
        }
        case 11: {
          msg.maxRetries = reader.readInt32();
          break;
        }
        case 12: {
          msg.timeoutSeconds = reader.readInt32();
          break;
        }
        case 13: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 14: {
          reader.readMessage(msg.updatedAt, protoscript.Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Variables: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Workflow.Variables>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Workflow.Variables,
      reader: protoscript.BinaryReader,
    ): Workflow.Variables {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const WorkflowStep = {
  /**
   * Serializes WorkflowStep to protobuf.
   */
  encode: function (msg: PartialDeep<WorkflowStep>): Uint8Array {
    return WorkflowStep._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WorkflowStep from protobuf.
   */
  decode: function (bytes: ByteSource): WorkflowStep {
    return WorkflowStep._readMessage(
      WorkflowStep.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WorkflowStep with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WorkflowStep>): WorkflowStep {
    return {
      id: "",
      name: "",
      description: "",
      type: "",
      parameters: {},
      onSuccess: "",
      onFailure: "",
      timeoutSeconds: 0,
      retryAttempts: 0,
      async: false,
      outputs: {},
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WorkflowStep>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.name) {
      writer.writeString(2, msg.name);
    }
    if (msg.description) {
      writer.writeString(3, msg.description);
    }
    if (msg.type) {
      writer.writeString(4, msg.type);
    }
    if (msg.parameters) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.parameters).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        WorkflowStep.Parameters._writeMessage,
      );
    }
    if (msg.onSuccess) {
      writer.writeString(6, msg.onSuccess);
    }
    if (msg.onFailure) {
      writer.writeString(7, msg.onFailure);
    }
    if (msg.timeoutSeconds) {
      writer.writeInt32(8, msg.timeoutSeconds);
    }
    if (msg.retryAttempts) {
      writer.writeInt32(9, msg.retryAttempts);
    }
    if (msg.async) {
      writer.writeBool(10, msg.async);
    }
    if (msg.outputs) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.outputs).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        WorkflowStep.Outputs._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WorkflowStep,
    reader: protoscript.BinaryReader,
  ): WorkflowStep {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.name = reader.readString();
          break;
        }
        case 3: {
          msg.description = reader.readString();
          break;
        }
        case 4: {
          msg.type = reader.readString();
          break;
        }
        case 5: {
          const map = {} as WorkflowStep.Parameters;
          reader.readMessage(map, WorkflowStep.Parameters._readMessage);
          msg.parameters[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          msg.onSuccess = reader.readString();
          break;
        }
        case 7: {
          msg.onFailure = reader.readString();
          break;
        }
        case 8: {
          msg.timeoutSeconds = reader.readInt32();
          break;
        }
        case 9: {
          msg.retryAttempts = reader.readInt32();
          break;
        }
        case 10: {
          msg.async = reader.readBool();
          break;
        }
        case 11: {
          const map = {} as WorkflowStep.Outputs;
          reader.readMessage(map, WorkflowStep.Outputs._readMessage);
          msg.outputs[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Parameters: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<WorkflowStep.Parameters>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: WorkflowStep.Parameters,
      reader: protoscript.BinaryReader,
    ): WorkflowStep.Parameters {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Outputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<WorkflowStep.Outputs>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: WorkflowStep.Outputs,
      reader: protoscript.BinaryReader,
    ): WorkflowStep.Outputs {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const WorkflowExecution = {
  /**
   * Serializes WorkflowExecution to protobuf.
   */
  encode: function (msg: PartialDeep<WorkflowExecution>): Uint8Array {
    return WorkflowExecution._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WorkflowExecution from protobuf.
   */
  decode: function (bytes: ByteSource): WorkflowExecution {
    return WorkflowExecution._readMessage(
      WorkflowExecution.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WorkflowExecution with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WorkflowExecution>): WorkflowExecution {
    return {
      id: "",
      workflowId: "",
      status: "",
      startedBy: "",
      applicationId: "",
      inputs: {},
      outputs: {},
      error: "",
      startedAt: protoscript.Timestamp.initialize(),
      completedAt: protoscript.Timestamp.initialize(),
      createdAt: protoscript.Timestamp.initialize(),
      updatedAt: protoscript.Timestamp.initialize(),
      steps: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WorkflowExecution>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.workflowId) {
      writer.writeString(2, msg.workflowId);
    }
    if (msg.status) {
      writer.writeString(3, msg.status);
    }
    if (msg.startedBy) {
      writer.writeString(4, msg.startedBy);
    }
    if (msg.applicationId) {
      writer.writeString(5, msg.applicationId);
    }
    if (msg.inputs) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.inputs).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        WorkflowExecution.Inputs._writeMessage,
      );
    }
    if (msg.outputs) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.outputs).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        WorkflowExecution.Outputs._writeMessage,
      );
    }
    if (msg.error) {
      writer.writeString(8, msg.error);
    }
    if (msg.startedAt) {
      writer.writeMessage(
        9,
        msg.startedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.completedAt) {
      writer.writeMessage(
        10,
        msg.completedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.createdAt) {
      writer.writeMessage(
        11,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.updatedAt) {
      writer.writeMessage(
        12,
        msg.updatedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.steps?.length) {
      writer.writeRepeatedMessage(
        13,
        msg.steps as any,
        ExecutionStep._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WorkflowExecution,
    reader: protoscript.BinaryReader,
  ): WorkflowExecution {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.workflowId = reader.readString();
          break;
        }
        case 3: {
          msg.status = reader.readString();
          break;
        }
        case 4: {
          msg.startedBy = reader.readString();
          break;
        }
        case 5: {
          msg.applicationId = reader.readString();
          break;
        }
        case 6: {
          const map = {} as WorkflowExecution.Inputs;
          reader.readMessage(map, WorkflowExecution.Inputs._readMessage);
          msg.inputs[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {} as WorkflowExecution.Outputs;
          reader.readMessage(map, WorkflowExecution.Outputs._readMessage);
          msg.outputs[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          msg.error = reader.readString();
          break;
        }
        case 9: {
          reader.readMessage(msg.startedAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(
            msg.completedAt,
            protoscript.Timestamp._readMessage,
          );
          break;
        }
        case 11: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 12: {
          reader.readMessage(msg.updatedAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 13: {
          const m = ExecutionStep.initialize();
          reader.readMessage(m, ExecutionStep._readMessage);
          msg.steps.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Inputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<WorkflowExecution.Inputs>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: WorkflowExecution.Inputs,
      reader: protoscript.BinaryReader,
    ): WorkflowExecution.Inputs {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Outputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<WorkflowExecution.Outputs>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: WorkflowExecution.Outputs,
      reader: protoscript.BinaryReader,
    ): WorkflowExecution.Outputs {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const ExecutionStep = {
  /**
   * Serializes ExecutionStep to protobuf.
   */
  encode: function (msg: PartialDeep<ExecutionStep>): Uint8Array {
    return ExecutionStep._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ExecutionStep from protobuf.
   */
  decode: function (bytes: ByteSource): ExecutionStep {
    return ExecutionStep._readMessage(
      ExecutionStep.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ExecutionStep with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ExecutionStep>): ExecutionStep {
    return {
      stepId: "",
      name: "",
      status: "",
      attempt: 0,
      error: "",
      inputs: {},
      outputs: {},
      startedAt: protoscript.Timestamp.initialize(),
      completedAt: protoscript.Timestamp.initialize(),
      durationMs: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ExecutionStep>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.stepId) {
      writer.writeString(1, msg.stepId);
    }
    if (msg.name) {
      writer.writeString(2, msg.name);
    }
    if (msg.status) {
      writer.writeString(3, msg.status);
    }
    if (msg.attempt) {
      writer.writeInt32(4, msg.attempt);
    }
    if (msg.error) {
      writer.writeString(5, msg.error);
    }
    if (msg.inputs) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.inputs).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        ExecutionStep.Inputs._writeMessage,
      );
    }
    if (msg.outputs) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.outputs).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        ExecutionStep.Outputs._writeMessage,
      );
    }
    if (msg.startedAt) {
      writer.writeMessage(
        8,
        msg.startedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.completedAt) {
      writer.writeMessage(
        9,
        msg.completedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.durationMs) {
      writer.writeInt64String(10, msg.durationMs.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ExecutionStep,
    reader: protoscript.BinaryReader,
  ): ExecutionStep {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.stepId = reader.readString();
          break;
        }
        case 2: {
          msg.name = reader.readString();
          break;
        }
        case 3: {
          msg.status = reader.readString();
          break;
        }
        case 4: {
          msg.attempt = reader.readInt32();
          break;
        }
        case 5: {
          msg.error = reader.readString();
          break;
        }
        case 6: {
          const map = {} as ExecutionStep.Inputs;
          reader.readMessage(map, ExecutionStep.Inputs._readMessage);
          msg.inputs[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {} as ExecutionStep.Outputs;
          reader.readMessage(map, ExecutionStep.Outputs._readMessage);
          msg.outputs[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          reader.readMessage(msg.startedAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 9: {
          reader.readMessage(
            msg.completedAt,
            protoscript.Timestamp._readMessage,
          );
          break;
        }
        case 10: {
          msg.durationMs = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Inputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ExecutionStep.Inputs>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ExecutionStep.Inputs,
      reader: protoscript.BinaryReader,
    ): ExecutionStep.Inputs {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Outputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ExecutionStep.Outputs>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ExecutionStep.Outputs,
      reader: protoscript.BinaryReader,
    ): ExecutionStep.Outputs {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const CreateWorkflowRequest = {
  /**
   * Serializes CreateWorkflowRequest to protobuf.
   */
  encode: function (msg: PartialDeep<CreateWorkflowRequest>): Uint8Array {
    return CreateWorkflowRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CreateWorkflowRequest from protobuf.
   */
  decode: function (bytes: ByteSource): CreateWorkflowRequest {
    return CreateWorkflowRequest._readMessage(
      CreateWorkflowRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CreateWorkflowRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CreateWorkflowRequest>,
  ): CreateWorkflowRequest {
    return {
      name: "",
      description: "",
      applicationId: "",
      createdBy: "",
      enabled: false,
      steps: [],
      variables: {},
      onSuccess: "",
      onFailure: "",
      maxRetries: 0,
      timeoutSeconds: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateWorkflowRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.description) {
      writer.writeString(2, msg.description);
    }
    if (msg.applicationId) {
      writer.writeString(3, msg.applicationId);
    }
    if (msg.createdBy) {
      writer.writeString(4, msg.createdBy);
    }
    if (msg.enabled) {
      writer.writeBool(5, msg.enabled);
    }
    if (msg.steps?.length) {
      writer.writeRepeatedMessage(
        6,
        msg.steps as any,
        WorkflowStep._writeMessage,
      );
    }
    if (msg.variables) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.variables).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        CreateWorkflowRequest.Variables._writeMessage,
      );
    }
    if (msg.onSuccess) {
      writer.writeString(8, msg.onSuccess);
    }
    if (msg.onFailure) {
      writer.writeString(9, msg.onFailure);
    }
    if (msg.maxRetries) {
      writer.writeInt32(10, msg.maxRetries);
    }
    if (msg.timeoutSeconds) {
      writer.writeInt32(11, msg.timeoutSeconds);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateWorkflowRequest,
    reader: protoscript.BinaryReader,
  ): CreateWorkflowRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.description = reader.readString();
          break;
        }
        case 3: {
          msg.applicationId = reader.readString();
          break;
        }
        case 4: {
          msg.createdBy = reader.readString();
          break;
        }
        case 5: {
          msg.enabled = reader.readBool();
          break;
        }
        case 6: {
          const m = WorkflowStep.initialize();
          reader.readMessage(m, WorkflowStep._readMessage);
          msg.steps.push(m);
          break;
        }
        case 7: {
          const map = {} as CreateWorkflowRequest.Variables;
          reader.readMessage(map, CreateWorkflowRequest.Variables._readMessage);
          msg.variables[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          msg.onSuccess = reader.readString();
          break;
        }
        case 9: {
          msg.onFailure = reader.readString();
          break;
        }
        case 10: {
          msg.maxRetries = reader.readInt32();
          break;
        }
        case 11: {
          msg.timeoutSeconds = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Variables: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<CreateWorkflowRequest.Variables>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: CreateWorkflowRequest.Variables,
      reader: protoscript.BinaryReader,
    ): CreateWorkflowRequest.Variables {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const GetWorkflowRequest = {
  /**
   * Serializes GetWorkflowRequest to protobuf.
   */
  encode: function (msg: PartialDeep<GetWorkflowRequest>): Uint8Array {
    return GetWorkflowRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GetWorkflowRequest from protobuf.
   */
  decode: function (bytes: ByteSource): GetWorkflowRequest {
    return GetWorkflowRequest._readMessage(
      GetWorkflowRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GetWorkflowRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetWorkflowRequest>): GetWorkflowRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetWorkflowRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetWorkflowRequest,
    reader: protoscript.BinaryReader,
  ): GetWorkflowRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const WorkflowResponse = {
  /**
   * Serializes WorkflowResponse to protobuf.
   */
  encode: function (msg: PartialDeep<WorkflowResponse>): Uint8Array {
    return WorkflowResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WorkflowResponse from protobuf.
   */
  decode: function (bytes: ByteSource): WorkflowResponse {
    return WorkflowResponse._readMessage(
      WorkflowResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WorkflowResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WorkflowResponse>): WorkflowResponse {
    return {
      status: common.ResponseStatus.initialize(),
      workflow: Workflow.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WorkflowResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.status) {
      writer.writeMessage(1, msg.status, common.ResponseStatus._writeMessage);
    }
    if (msg.workflow) {
      writer.writeMessage(2, msg.workflow, Workflow._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WorkflowResponse,
    reader: protoscript.BinaryReader,
  ): WorkflowResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.status, common.ResponseStatus._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.workflow, Workflow._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const UpdateWorkflowRequest = {
  /**
   * Serializes UpdateWorkflowRequest to protobuf.
   */
  encode: function (msg: PartialDeep<UpdateWorkflowRequest>): Uint8Array {
    return UpdateWorkflowRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes UpdateWorkflowRequest from protobuf.
   */
  decode: function (bytes: ByteSource): UpdateWorkflowRequest {
    return UpdateWorkflowRequest._readMessage(
      UpdateWorkflowRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes UpdateWorkflowRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<UpdateWorkflowRequest>,
  ): UpdateWorkflowRequest {
    return {
      id: "",
      name: "",
      description: "",
      enabled: false,
      steps: [],
      variables: {},
      onSuccess: "",
      onFailure: "",
      maxRetries: 0,
      timeoutSeconds: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UpdateWorkflowRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.name) {
      writer.writeString(2, msg.name);
    }
    if (msg.description) {
      writer.writeString(3, msg.description);
    }
    if (msg.enabled) {
      writer.writeBool(4, msg.enabled);
    }
    if (msg.steps?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.steps as any,
        WorkflowStep._writeMessage,
      );
    }
    if (msg.variables) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.variables).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        UpdateWorkflowRequest.Variables._writeMessage,
      );
    }
    if (msg.onSuccess) {
      writer.writeString(7, msg.onSuccess);
    }
    if (msg.onFailure) {
      writer.writeString(8, msg.onFailure);
    }
    if (msg.maxRetries) {
      writer.writeInt32(9, msg.maxRetries);
    }
    if (msg.timeoutSeconds) {
      writer.writeInt32(10, msg.timeoutSeconds);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UpdateWorkflowRequest,
    reader: protoscript.BinaryReader,
  ): UpdateWorkflowRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.name = reader.readString();
          break;
        }
        case 3: {
          msg.description = reader.readString();
          break;
        }
        case 4: {
          msg.enabled = reader.readBool();
          break;
        }
        case 5: {
          const m = WorkflowStep.initialize();
          reader.readMessage(m, WorkflowStep._readMessage);
          msg.steps.push(m);
          break;
        }
        case 6: {
          const map = {} as UpdateWorkflowRequest.Variables;
          reader.readMessage(map, UpdateWorkflowRequest.Variables._readMessage);
          msg.variables[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          msg.onSuccess = reader.readString();
          break;
        }
        case 8: {
          msg.onFailure = reader.readString();
          break;
        }
        case 9: {
          msg.maxRetries = reader.readInt32();
          break;
        }
        case 10: {
          msg.timeoutSeconds = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Variables: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<UpdateWorkflowRequest.Variables>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: UpdateWorkflowRequest.Variables,
      reader: protoscript.BinaryReader,
    ): UpdateWorkflowRequest.Variables {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const DeleteWorkflowRequest = {
  /**
   * Serializes DeleteWorkflowRequest to protobuf.
   */
  encode: function (msg: PartialDeep<DeleteWorkflowRequest>): Uint8Array {
    return DeleteWorkflowRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes DeleteWorkflowRequest from protobuf.
   */
  decode: function (bytes: ByteSource): DeleteWorkflowRequest {
    return DeleteWorkflowRequest._readMessage(
      DeleteWorkflowRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes DeleteWorkflowRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<DeleteWorkflowRequest>,
  ): DeleteWorkflowRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DeleteWorkflowRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DeleteWorkflowRequest,
    reader: protoscript.BinaryReader,
  ): DeleteWorkflowRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListWorkflowsRequest = {
  /**
   * Serializes ListWorkflowsRequest to protobuf.
   */
  encode: function (msg: PartialDeep<ListWorkflowsRequest>): Uint8Array {
    return ListWorkflowsRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListWorkflowsRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ListWorkflowsRequest {
    return ListWorkflowsRequest._readMessage(
      ListWorkflowsRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListWorkflowsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListWorkflowsRequest>,
  ): ListWorkflowsRequest {
    return {
      applicationId: "",
      includeDisabled: false,
      page: 0,
      pageSize: 0,
      sortBy: "",
      sortDesc: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListWorkflowsRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.applicationId) {
      writer.writeString(1, msg.applicationId);
    }
    if (msg.includeDisabled) {
      writer.writeBool(2, msg.includeDisabled);
    }
    if (msg.page) {
      writer.writeInt32(3, msg.page);
    }
    if (msg.pageSize) {
      writer.writeInt32(4, msg.pageSize);
    }
    if (msg.sortBy) {
      writer.writeString(5, msg.sortBy);
    }
    if (msg.sortDesc) {
      writer.writeBool(6, msg.sortDesc);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListWorkflowsRequest,
    reader: protoscript.BinaryReader,
  ): ListWorkflowsRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.applicationId = reader.readString();
          break;
        }
        case 2: {
          msg.includeDisabled = reader.readBool();
          break;
        }
        case 3: {
          msg.page = reader.readInt32();
          break;
        }
        case 4: {
          msg.pageSize = reader.readInt32();
          break;
        }
        case 5: {
          msg.sortBy = reader.readString();
          break;
        }
        case 6: {
          msg.sortDesc = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListWorkflowsResponse = {
  /**
   * Serializes ListWorkflowsResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ListWorkflowsResponse>): Uint8Array {
    return ListWorkflowsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListWorkflowsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListWorkflowsResponse {
    return ListWorkflowsResponse._readMessage(
      ListWorkflowsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListWorkflowsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListWorkflowsResponse>,
  ): ListWorkflowsResponse {
    return {
      status: common.ResponseStatus.initialize(),
      workflows: [],
      totalCount: 0,
      page: 0,
      pageSize: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListWorkflowsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.status) {
      writer.writeMessage(1, msg.status, common.ResponseStatus._writeMessage);
    }
    if (msg.workflows?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.workflows as any,
        Workflow._writeMessage,
      );
    }
    if (msg.totalCount) {
      writer.writeInt32(3, msg.totalCount);
    }
    if (msg.page) {
      writer.writeInt32(4, msg.page);
    }
    if (msg.pageSize) {
      writer.writeInt32(5, msg.pageSize);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListWorkflowsResponse,
    reader: protoscript.BinaryReader,
  ): ListWorkflowsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.status, common.ResponseStatus._readMessage);
          break;
        }
        case 2: {
          const m = Workflow.initialize();
          reader.readMessage(m, Workflow._readMessage);
          msg.workflows.push(m);
          break;
        }
        case 3: {
          msg.totalCount = reader.readInt32();
          break;
        }
        case 4: {
          msg.page = reader.readInt32();
          break;
        }
        case 5: {
          msg.pageSize = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ExecuteWorkflowRequest = {
  /**
   * Serializes ExecuteWorkflowRequest to protobuf.
   */
  encode: function (msg: PartialDeep<ExecuteWorkflowRequest>): Uint8Array {
    return ExecuteWorkflowRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ExecuteWorkflowRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ExecuteWorkflowRequest {
    return ExecuteWorkflowRequest._readMessage(
      ExecuteWorkflowRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ExecuteWorkflowRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ExecuteWorkflowRequest>,
  ): ExecuteWorkflowRequest {
    return {
      workflowId: "",
      applicationId: "",
      startedBy: "",
      inputs: {},
      async: false,
      correlationId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ExecuteWorkflowRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.workflowId) {
      writer.writeString(1, msg.workflowId);
    }
    if (msg.applicationId) {
      writer.writeString(2, msg.applicationId);
    }
    if (msg.startedBy) {
      writer.writeString(3, msg.startedBy);
    }
    if (msg.inputs) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.inputs).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        ExecuteWorkflowRequest.Inputs._writeMessage,
      );
    }
    if (msg.async) {
      writer.writeBool(5, msg.async);
    }
    if (msg.correlationId) {
      writer.writeString(6, msg.correlationId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ExecuteWorkflowRequest,
    reader: protoscript.BinaryReader,
  ): ExecuteWorkflowRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.workflowId = reader.readString();
          break;
        }
        case 2: {
          msg.applicationId = reader.readString();
          break;
        }
        case 3: {
          msg.startedBy = reader.readString();
          break;
        }
        case 4: {
          const map = {} as ExecuteWorkflowRequest.Inputs;
          reader.readMessage(map, ExecuteWorkflowRequest.Inputs._readMessage);
          msg.inputs[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          msg.async = reader.readBool();
          break;
        }
        case 6: {
          msg.correlationId = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Inputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ExecuteWorkflowRequest.Inputs>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ExecuteWorkflowRequest.Inputs,
      reader: protoscript.BinaryReader,
    ): ExecuteWorkflowRequest.Inputs {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const ExecuteWorkflowResponse = {
  /**
   * Serializes ExecuteWorkflowResponse to protobuf.
   */
  encode: function (msg: PartialDeep<ExecuteWorkflowResponse>): Uint8Array {
    return ExecuteWorkflowResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ExecuteWorkflowResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ExecuteWorkflowResponse {
    return ExecuteWorkflowResponse._readMessage(
      ExecuteWorkflowResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ExecuteWorkflowResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ExecuteWorkflowResponse>,
  ): ExecuteWorkflowResponse {
    return {
      status: common.ResponseStatus.initialize(),
      executionId: "",
      async: false,
      statusUrl: "",
      outputs: {},
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ExecuteWorkflowResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.status) {
      writer.writeMessage(1, msg.status, common.ResponseStatus._writeMessage);
    }
    if (msg.executionId) {
      writer.writeString(2, msg.executionId);
    }
    if (msg.async) {
      writer.writeBool(3, msg.async);
    }
    if (msg.statusUrl) {
      writer.writeString(4, msg.statusUrl);
    }
    if (msg.outputs) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.outputs).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        ExecuteWorkflowResponse.Outputs._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ExecuteWorkflowResponse,
    reader: protoscript.BinaryReader,
  ): ExecuteWorkflowResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.status, common.ResponseStatus._readMessage);
          break;
        }
        case 2: {
          msg.executionId = reader.readString();
          break;
        }
        case 3: {
          msg.async = reader.readBool();
          break;
        }
        case 4: {
          msg.statusUrl = reader.readString();
          break;
        }
        case 5: {
          const map = {} as ExecuteWorkflowResponse.Outputs;
          reader.readMessage(map, ExecuteWorkflowResponse.Outputs._readMessage);
          msg.outputs[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Outputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ExecuteWorkflowResponse.Outputs>,
      writer: protoscript.BinaryWriter,
    ): protoscript.BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ExecuteWorkflowResponse.Outputs,
      reader: protoscript.BinaryReader,
    ): ExecuteWorkflowResponse.Outputs {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const GetWorkflowExecutionRequest = {
  /**
   * Serializes GetWorkflowExecutionRequest to protobuf.
   */
  encode: function (msg: PartialDeep<GetWorkflowExecutionRequest>): Uint8Array {
    return GetWorkflowExecutionRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GetWorkflowExecutionRequest from protobuf.
   */
  decode: function (bytes: ByteSource): GetWorkflowExecutionRequest {
    return GetWorkflowExecutionRequest._readMessage(
      GetWorkflowExecutionRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GetWorkflowExecutionRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetWorkflowExecutionRequest>,
  ): GetWorkflowExecutionRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetWorkflowExecutionRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetWorkflowExecutionRequest,
    reader: protoscript.BinaryReader,
  ): GetWorkflowExecutionRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const WorkflowExecutionResponse = {
  /**
   * Serializes WorkflowExecutionResponse to protobuf.
   */
  encode: function (msg: PartialDeep<WorkflowExecutionResponse>): Uint8Array {
    return WorkflowExecutionResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WorkflowExecutionResponse from protobuf.
   */
  decode: function (bytes: ByteSource): WorkflowExecutionResponse {
    return WorkflowExecutionResponse._readMessage(
      WorkflowExecutionResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WorkflowExecutionResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<WorkflowExecutionResponse>,
  ): WorkflowExecutionResponse {
    return {
      status: common.ResponseStatus.initialize(),
      execution: WorkflowExecution.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WorkflowExecutionResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.status) {
      writer.writeMessage(1, msg.status, common.ResponseStatus._writeMessage);
    }
    if (msg.execution) {
      writer.writeMessage(2, msg.execution, WorkflowExecution._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WorkflowExecutionResponse,
    reader: protoscript.BinaryReader,
  ): WorkflowExecutionResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.status, common.ResponseStatus._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.execution, WorkflowExecution._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListWorkflowExecutionsRequest = {
  /**
   * Serializes ListWorkflowExecutionsRequest to protobuf.
   */
  encode: function (
    msg: PartialDeep<ListWorkflowExecutionsRequest>,
  ): Uint8Array {
    return ListWorkflowExecutionsRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListWorkflowExecutionsRequest from protobuf.
   */
  decode: function (bytes: ByteSource): ListWorkflowExecutionsRequest {
    return ListWorkflowExecutionsRequest._readMessage(
      ListWorkflowExecutionsRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListWorkflowExecutionsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListWorkflowExecutionsRequest>,
  ): ListWorkflowExecutionsRequest {
    return {
      workflowId: "",
      applicationId: "",
      status: "",
      startedBy: "",
      from: protoscript.Timestamp.initialize(),
      to: protoscript.Timestamp.initialize(),
      page: 0,
      pageSize: 0,
      sortBy: "",
      sortDesc: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListWorkflowExecutionsRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.workflowId) {
      writer.writeString(1, msg.workflowId);
    }
    if (msg.applicationId) {
      writer.writeString(2, msg.applicationId);
    }
    if (msg.status) {
      writer.writeString(3, msg.status);
    }
    if (msg.startedBy) {
      writer.writeString(4, msg.startedBy);
    }
    if (msg.from) {
      writer.writeMessage(5, msg.from, protoscript.Timestamp._writeMessage);
    }
    if (msg.to) {
      writer.writeMessage(6, msg.to, protoscript.Timestamp._writeMessage);
    }
    if (msg.page) {
      writer.writeInt32(7, msg.page);
    }
    if (msg.pageSize) {
      writer.writeInt32(8, msg.pageSize);
    }
    if (msg.sortBy) {
      writer.writeString(9, msg.sortBy);
    }
    if (msg.sortDesc) {
      writer.writeBool(10, msg.sortDesc);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListWorkflowExecutionsRequest,
    reader: protoscript.BinaryReader,
  ): ListWorkflowExecutionsRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.workflowId = reader.readString();
          break;
        }
        case 2: {
          msg.applicationId = reader.readString();
          break;
        }
        case 3: {
          msg.status = reader.readString();
          break;
        }
        case 4: {
          msg.startedBy = reader.readString();
          break;
        }
        case 5: {
          reader.readMessage(msg.from, protoscript.Timestamp._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(msg.to, protoscript.Timestamp._readMessage);
          break;
        }
        case 7: {
          msg.page = reader.readInt32();
          break;
        }
        case 8: {
          msg.pageSize = reader.readInt32();
          break;
        }
        case 9: {
          msg.sortBy = reader.readString();
          break;
        }
        case 10: {
          msg.sortDesc = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ListWorkflowExecutionsResponse = {
  /**
   * Serializes ListWorkflowExecutionsResponse to protobuf.
   */
  encode: function (
    msg: PartialDeep<ListWorkflowExecutionsResponse>,
  ): Uint8Array {
    return ListWorkflowExecutionsResponse._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ListWorkflowExecutionsResponse from protobuf.
   */
  decode: function (bytes: ByteSource): ListWorkflowExecutionsResponse {
    return ListWorkflowExecutionsResponse._readMessage(
      ListWorkflowExecutionsResponse.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes ListWorkflowExecutionsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListWorkflowExecutionsResponse>,
  ): ListWorkflowExecutionsResponse {
    return {
      status: common.ResponseStatus.initialize(),
      executions: [],
      totalCount: 0,
      page: 0,
      pageSize: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListWorkflowExecutionsResponse>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.status) {
      writer.writeMessage(1, msg.status, common.ResponseStatus._writeMessage);
    }
    if (msg.executions?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.executions as any,
        WorkflowExecution._writeMessage,
      );
    }
    if (msg.totalCount) {
      writer.writeInt32(3, msg.totalCount);
    }
    if (msg.page) {
      writer.writeInt32(4, msg.page);
    }
    if (msg.pageSize) {
      writer.writeInt32(5, msg.pageSize);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListWorkflowExecutionsResponse,
    reader: protoscript.BinaryReader,
  ): ListWorkflowExecutionsResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.status, common.ResponseStatus._readMessage);
          break;
        }
        case 2: {
          const m = WorkflowExecution.initialize();
          reader.readMessage(m, WorkflowExecution._readMessage);
          msg.executions.push(m);
          break;
        }
        case 3: {
          msg.totalCount = reader.readInt32();
          break;
        }
        case 4: {
          msg.page = reader.readInt32();
          break;
        }
        case 5: {
          msg.pageSize = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CancelWorkflowExecutionRequest = {
  /**
   * Serializes CancelWorkflowExecutionRequest to protobuf.
   */
  encode: function (
    msg: PartialDeep<CancelWorkflowExecutionRequest>,
  ): Uint8Array {
    return CancelWorkflowExecutionRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CancelWorkflowExecutionRequest from protobuf.
   */
  decode: function (bytes: ByteSource): CancelWorkflowExecutionRequest {
    return CancelWorkflowExecutionRequest._readMessage(
      CancelWorkflowExecutionRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CancelWorkflowExecutionRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CancelWorkflowExecutionRequest>,
  ): CancelWorkflowExecutionRequest {
    return {
      id: "",
      reason: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CancelWorkflowExecutionRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeString(1, msg.id);
    }
    if (msg.reason) {
      writer.writeString(2, msg.reason);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelWorkflowExecutionRequest,
    reader: protoscript.BinaryReader,
  ): CancelWorkflowExecutionRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readString();
          break;
        }
        case 2: {
          msg.reason = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const WorkflowJSON = {
  /**
   * Serializes Workflow to JSON.
   */
  encode: function (msg: PartialDeep<Workflow>): string {
    return JSON.stringify(WorkflowJSON._writeMessage(msg));
  },

  /**
   * Deserializes Workflow from JSON.
   */
  decode: function (json: string): Workflow {
    return WorkflowJSON._readMessage(
      WorkflowJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Workflow with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Workflow>): Workflow {
    return {
      id: "",
      name: "",
      description: "",
      applicationId: "",
      createdBy: "",
      enabled: false,
      steps: [],
      variables: {},
      onSuccess: "",
      onFailure: "",
      maxRetries: 0,
      timeoutSeconds: 0,
      createdAt: protoscript.TimestampJSON.initialize(),
      updatedAt: protoscript.TimestampJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Workflow>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    if (msg.applicationId) {
      json["applicationId"] = msg.applicationId;
    }
    if (msg.createdBy) {
      json["createdBy"] = msg.createdBy;
    }
    if (msg.enabled) {
      json["enabled"] = msg.enabled;
    }
    if (msg.steps?.length) {
      json["steps"] = msg.steps.map(WorkflowStepJSON._writeMessage);
    }
    if (msg.variables) {
      const _variables_ = Object.fromEntries(
        Object.entries(msg.variables)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(WorkflowJSON.Variables._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_variables_).length > 0) {
        json["variables"] = _variables_;
      }
    }
    if (msg.onSuccess) {
      json["onSuccess"] = msg.onSuccess;
    }
    if (msg.onFailure) {
      json["onFailure"] = msg.onFailure;
    }
    if (msg.maxRetries) {
      json["maxRetries"] = msg.maxRetries;
    }
    if (msg.timeoutSeconds) {
      json["timeoutSeconds"] = msg.timeoutSeconds;
    }
    if (msg.createdAt && (msg.createdAt.seconds || msg.createdAt.nanos)) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.updatedAt && (msg.updatedAt.seconds || msg.updatedAt.nanos)) {
      json["updatedAt"] = protoscript.serializeTimestamp(msg.updatedAt);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Workflow, json: any): Workflow {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _applicationId_ = json["applicationId"] ?? json["application_id"];
    if (_applicationId_) {
      msg.applicationId = _applicationId_;
    }
    const _createdBy_ = json["createdBy"] ?? json["created_by"];
    if (_createdBy_) {
      msg.createdBy = _createdBy_;
    }
    const _enabled_ = json["enabled"];
    if (_enabled_) {
      msg.enabled = _enabled_;
    }
    const _steps_ = json["steps"];
    if (_steps_) {
      for (const item of _steps_) {
        const m = WorkflowStepJSON.initialize();
        WorkflowStepJSON._readMessage(m, item);
        msg.steps.push(m);
      }
    }
    const _variables_ = json["variables"];
    if (_variables_) {
      msg.variables = Object.fromEntries(
        Object.entries(_variables_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(WorkflowJSON.Variables._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _onSuccess_ = json["onSuccess"] ?? json["on_success"];
    if (_onSuccess_) {
      msg.onSuccess = _onSuccess_;
    }
    const _onFailure_ = json["onFailure"] ?? json["on_failure"];
    if (_onFailure_) {
      msg.onFailure = _onFailure_;
    }
    const _maxRetries_ = json["maxRetries"] ?? json["max_retries"];
    if (_maxRetries_) {
      msg.maxRetries = protoscript.parseNumber(_maxRetries_);
    }
    const _timeoutSeconds_ = json["timeoutSeconds"] ?? json["timeout_seconds"];
    if (_timeoutSeconds_) {
      msg.timeoutSeconds = protoscript.parseNumber(_timeoutSeconds_);
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _updatedAt_ = json["updatedAt"] ?? json["updated_at"];
    if (_updatedAt_) {
      msg.updatedAt = protoscript.parseTimestamp(_updatedAt_);
    }
    return msg;
  },

  Variables: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Workflow.Variables>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Workflow.Variables,
      json: any,
    ): Workflow.Variables {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const WorkflowStepJSON = {
  /**
   * Serializes WorkflowStep to JSON.
   */
  encode: function (msg: PartialDeep<WorkflowStep>): string {
    return JSON.stringify(WorkflowStepJSON._writeMessage(msg));
  },

  /**
   * Deserializes WorkflowStep from JSON.
   */
  decode: function (json: string): WorkflowStep {
    return WorkflowStepJSON._readMessage(
      WorkflowStepJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WorkflowStep with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WorkflowStep>): WorkflowStep {
    return {
      id: "",
      name: "",
      description: "",
      type: "",
      parameters: {},
      onSuccess: "",
      onFailure: "",
      timeoutSeconds: 0,
      retryAttempts: 0,
      async: false,
      outputs: {},
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WorkflowStep>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    if (msg.type) {
      json["type"] = msg.type;
    }
    if (msg.parameters) {
      const _parameters_ = Object.fromEntries(
        Object.entries(msg.parameters)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(WorkflowStepJSON.Parameters._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_parameters_).length > 0) {
        json["parameters"] = _parameters_;
      }
    }
    if (msg.onSuccess) {
      json["onSuccess"] = msg.onSuccess;
    }
    if (msg.onFailure) {
      json["onFailure"] = msg.onFailure;
    }
    if (msg.timeoutSeconds) {
      json["timeoutSeconds"] = msg.timeoutSeconds;
    }
    if (msg.retryAttempts) {
      json["retryAttempts"] = msg.retryAttempts;
    }
    if (msg.async) {
      json["async"] = msg.async;
    }
    if (msg.outputs) {
      const _outputs_ = Object.fromEntries(
        Object.entries(msg.outputs)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(WorkflowStepJSON.Outputs._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_outputs_).length > 0) {
        json["outputs"] = _outputs_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: WorkflowStep, json: any): WorkflowStep {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _type_ = json["type"];
    if (_type_) {
      msg.type = _type_;
    }
    const _parameters_ = json["parameters"];
    if (_parameters_) {
      msg.parameters = Object.fromEntries(
        Object.entries(_parameters_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(WorkflowStepJSON.Parameters._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _onSuccess_ = json["onSuccess"] ?? json["on_success"];
    if (_onSuccess_) {
      msg.onSuccess = _onSuccess_;
    }
    const _onFailure_ = json["onFailure"] ?? json["on_failure"];
    if (_onFailure_) {
      msg.onFailure = _onFailure_;
    }
    const _timeoutSeconds_ = json["timeoutSeconds"] ?? json["timeout_seconds"];
    if (_timeoutSeconds_) {
      msg.timeoutSeconds = protoscript.parseNumber(_timeoutSeconds_);
    }
    const _retryAttempts_ = json["retryAttempts"] ?? json["retry_attempts"];
    if (_retryAttempts_) {
      msg.retryAttempts = protoscript.parseNumber(_retryAttempts_);
    }
    const _async_ = json["async"];
    if (_async_) {
      msg.async = _async_;
    }
    const _outputs_ = json["outputs"];
    if (_outputs_) {
      msg.outputs = Object.fromEntries(
        Object.entries(_outputs_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(WorkflowStepJSON.Outputs._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  Parameters: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<WorkflowStep.Parameters>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: WorkflowStep.Parameters,
      json: any,
    ): WorkflowStep.Parameters {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  Outputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<WorkflowStep.Outputs>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: WorkflowStep.Outputs,
      json: any,
    ): WorkflowStep.Outputs {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const WorkflowExecutionJSON = {
  /**
   * Serializes WorkflowExecution to JSON.
   */
  encode: function (msg: PartialDeep<WorkflowExecution>): string {
    return JSON.stringify(WorkflowExecutionJSON._writeMessage(msg));
  },

  /**
   * Deserializes WorkflowExecution from JSON.
   */
  decode: function (json: string): WorkflowExecution {
    return WorkflowExecutionJSON._readMessage(
      WorkflowExecutionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WorkflowExecution with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WorkflowExecution>): WorkflowExecution {
    return {
      id: "",
      workflowId: "",
      status: "",
      startedBy: "",
      applicationId: "",
      inputs: {},
      outputs: {},
      error: "",
      startedAt: protoscript.TimestampJSON.initialize(),
      completedAt: protoscript.TimestampJSON.initialize(),
      createdAt: protoscript.TimestampJSON.initialize(),
      updatedAt: protoscript.TimestampJSON.initialize(),
      steps: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WorkflowExecution>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.workflowId) {
      json["workflowId"] = msg.workflowId;
    }
    if (msg.status) {
      json["status"] = msg.status;
    }
    if (msg.startedBy) {
      json["startedBy"] = msg.startedBy;
    }
    if (msg.applicationId) {
      json["applicationId"] = msg.applicationId;
    }
    if (msg.inputs) {
      const _inputs_ = Object.fromEntries(
        Object.entries(msg.inputs)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(WorkflowExecutionJSON.Inputs._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_inputs_).length > 0) {
        json["inputs"] = _inputs_;
      }
    }
    if (msg.outputs) {
      const _outputs_ = Object.fromEntries(
        Object.entries(msg.outputs)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(WorkflowExecutionJSON.Outputs._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_outputs_).length > 0) {
        json["outputs"] = _outputs_;
      }
    }
    if (msg.error) {
      json["error"] = msg.error;
    }
    if (msg.startedAt && (msg.startedAt.seconds || msg.startedAt.nanos)) {
      json["startedAt"] = protoscript.serializeTimestamp(msg.startedAt);
    }
    if (msg.completedAt && (msg.completedAt.seconds || msg.completedAt.nanos)) {
      json["completedAt"] = protoscript.serializeTimestamp(msg.completedAt);
    }
    if (msg.createdAt && (msg.createdAt.seconds || msg.createdAt.nanos)) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.updatedAt && (msg.updatedAt.seconds || msg.updatedAt.nanos)) {
      json["updatedAt"] = protoscript.serializeTimestamp(msg.updatedAt);
    }
    if (msg.steps?.length) {
      json["steps"] = msg.steps.map(ExecutionStepJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WorkflowExecution,
    json: any,
  ): WorkflowExecution {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _workflowId_ = json["workflowId"] ?? json["workflow_id"];
    if (_workflowId_) {
      msg.workflowId = _workflowId_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = _status_;
    }
    const _startedBy_ = json["startedBy"] ?? json["started_by"];
    if (_startedBy_) {
      msg.startedBy = _startedBy_;
    }
    const _applicationId_ = json["applicationId"] ?? json["application_id"];
    if (_applicationId_) {
      msg.applicationId = _applicationId_;
    }
    const _inputs_ = json["inputs"];
    if (_inputs_) {
      msg.inputs = Object.fromEntries(
        Object.entries(_inputs_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(WorkflowExecutionJSON.Inputs._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _outputs_ = json["outputs"];
    if (_outputs_) {
      msg.outputs = Object.fromEntries(
        Object.entries(_outputs_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(WorkflowExecutionJSON.Outputs._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _error_ = json["error"];
    if (_error_) {
      msg.error = _error_;
    }
    const _startedAt_ = json["startedAt"] ?? json["started_at"];
    if (_startedAt_) {
      msg.startedAt = protoscript.parseTimestamp(_startedAt_);
    }
    const _completedAt_ = json["completedAt"] ?? json["completed_at"];
    if (_completedAt_) {
      msg.completedAt = protoscript.parseTimestamp(_completedAt_);
    }
    const _createdAt_ = json["createdAt"] ?? json["created_at"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _updatedAt_ = json["updatedAt"] ?? json["updated_at"];
    if (_updatedAt_) {
      msg.updatedAt = protoscript.parseTimestamp(_updatedAt_);
    }
    const _steps_ = json["steps"];
    if (_steps_) {
      for (const item of _steps_) {
        const m = ExecutionStepJSON.initialize();
        ExecutionStepJSON._readMessage(m, item);
        msg.steps.push(m);
      }
    }
    return msg;
  },

  Inputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<WorkflowExecution.Inputs>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: WorkflowExecution.Inputs,
      json: any,
    ): WorkflowExecution.Inputs {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  Outputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<WorkflowExecution.Outputs>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: WorkflowExecution.Outputs,
      json: any,
    ): WorkflowExecution.Outputs {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const ExecutionStepJSON = {
  /**
   * Serializes ExecutionStep to JSON.
   */
  encode: function (msg: PartialDeep<ExecutionStep>): string {
    return JSON.stringify(ExecutionStepJSON._writeMessage(msg));
  },

  /**
   * Deserializes ExecutionStep from JSON.
   */
  decode: function (json: string): ExecutionStep {
    return ExecutionStepJSON._readMessage(
      ExecutionStepJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ExecutionStep with all fields set to their default value.
   */
  initialize: function (msg?: Partial<ExecutionStep>): ExecutionStep {
    return {
      stepId: "",
      name: "",
      status: "",
      attempt: 0,
      error: "",
      inputs: {},
      outputs: {},
      startedAt: protoscript.TimestampJSON.initialize(),
      completedAt: protoscript.TimestampJSON.initialize(),
      durationMs: 0n,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ExecutionStep>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.stepId) {
      json["stepId"] = msg.stepId;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.status) {
      json["status"] = msg.status;
    }
    if (msg.attempt) {
      json["attempt"] = msg.attempt;
    }
    if (msg.error) {
      json["error"] = msg.error;
    }
    if (msg.inputs) {
      const _inputs_ = Object.fromEntries(
        Object.entries(msg.inputs)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(ExecutionStepJSON.Inputs._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_inputs_).length > 0) {
        json["inputs"] = _inputs_;
      }
    }
    if (msg.outputs) {
      const _outputs_ = Object.fromEntries(
        Object.entries(msg.outputs)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(ExecutionStepJSON.Outputs._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_outputs_).length > 0) {
        json["outputs"] = _outputs_;
      }
    }
    if (msg.startedAt && (msg.startedAt.seconds || msg.startedAt.nanos)) {
      json["startedAt"] = protoscript.serializeTimestamp(msg.startedAt);
    }
    if (msg.completedAt && (msg.completedAt.seconds || msg.completedAt.nanos)) {
      json["completedAt"] = protoscript.serializeTimestamp(msg.completedAt);
    }
    if (msg.durationMs) {
      json["durationMs"] = String(msg.durationMs);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ExecutionStep, json: any): ExecutionStep {
    const _stepId_ = json["stepId"] ?? json["step_id"];
    if (_stepId_) {
      msg.stepId = _stepId_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = _status_;
    }
    const _attempt_ = json["attempt"];
    if (_attempt_) {
      msg.attempt = protoscript.parseNumber(_attempt_);
    }
    const _error_ = json["error"];
    if (_error_) {
      msg.error = _error_;
    }
    const _inputs_ = json["inputs"];
    if (_inputs_) {
      msg.inputs = Object.fromEntries(
        Object.entries(_inputs_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(ExecutionStepJSON.Inputs._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _outputs_ = json["outputs"];
    if (_outputs_) {
      msg.outputs = Object.fromEntries(
        Object.entries(_outputs_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(ExecutionStepJSON.Outputs._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _startedAt_ = json["startedAt"] ?? json["started_at"];
    if (_startedAt_) {
      msg.startedAt = protoscript.parseTimestamp(_startedAt_);
    }
    const _completedAt_ = json["completedAt"] ?? json["completed_at"];
    if (_completedAt_) {
      msg.completedAt = protoscript.parseTimestamp(_completedAt_);
    }
    const _durationMs_ = json["durationMs"] ?? json["duration_ms"];
    if (_durationMs_) {
      msg.durationMs = BigInt(_durationMs_);
    }
    return msg;
  },

  Inputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ExecutionStep.Inputs>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ExecutionStep.Inputs,
      json: any,
    ): ExecutionStep.Inputs {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  Outputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ExecutionStep.Outputs>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ExecutionStep.Outputs,
      json: any,
    ): ExecutionStep.Outputs {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const CreateWorkflowRequestJSON = {
  /**
   * Serializes CreateWorkflowRequest to JSON.
   */
  encode: function (msg: PartialDeep<CreateWorkflowRequest>): string {
    return JSON.stringify(CreateWorkflowRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes CreateWorkflowRequest from JSON.
   */
  decode: function (json: string): CreateWorkflowRequest {
    return CreateWorkflowRequestJSON._readMessage(
      CreateWorkflowRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CreateWorkflowRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CreateWorkflowRequest>,
  ): CreateWorkflowRequest {
    return {
      name: "",
      description: "",
      applicationId: "",
      createdBy: "",
      enabled: false,
      steps: [],
      variables: {},
      onSuccess: "",
      onFailure: "",
      maxRetries: 0,
      timeoutSeconds: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateWorkflowRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    if (msg.applicationId) {
      json["applicationId"] = msg.applicationId;
    }
    if (msg.createdBy) {
      json["createdBy"] = msg.createdBy;
    }
    if (msg.enabled) {
      json["enabled"] = msg.enabled;
    }
    if (msg.steps?.length) {
      json["steps"] = msg.steps.map(WorkflowStepJSON._writeMessage);
    }
    if (msg.variables) {
      const _variables_ = Object.fromEntries(
        Object.entries(msg.variables)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(CreateWorkflowRequestJSON.Variables._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_variables_).length > 0) {
        json["variables"] = _variables_;
      }
    }
    if (msg.onSuccess) {
      json["onSuccess"] = msg.onSuccess;
    }
    if (msg.onFailure) {
      json["onFailure"] = msg.onFailure;
    }
    if (msg.maxRetries) {
      json["maxRetries"] = msg.maxRetries;
    }
    if (msg.timeoutSeconds) {
      json["timeoutSeconds"] = msg.timeoutSeconds;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateWorkflowRequest,
    json: any,
  ): CreateWorkflowRequest {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _applicationId_ = json["applicationId"] ?? json["application_id"];
    if (_applicationId_) {
      msg.applicationId = _applicationId_;
    }
    const _createdBy_ = json["createdBy"] ?? json["created_by"];
    if (_createdBy_) {
      msg.createdBy = _createdBy_;
    }
    const _enabled_ = json["enabled"];
    if (_enabled_) {
      msg.enabled = _enabled_;
    }
    const _steps_ = json["steps"];
    if (_steps_) {
      for (const item of _steps_) {
        const m = WorkflowStepJSON.initialize();
        WorkflowStepJSON._readMessage(m, item);
        msg.steps.push(m);
      }
    }
    const _variables_ = json["variables"];
    if (_variables_) {
      msg.variables = Object.fromEntries(
        Object.entries(_variables_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(CreateWorkflowRequestJSON.Variables._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _onSuccess_ = json["onSuccess"] ?? json["on_success"];
    if (_onSuccess_) {
      msg.onSuccess = _onSuccess_;
    }
    const _onFailure_ = json["onFailure"] ?? json["on_failure"];
    if (_onFailure_) {
      msg.onFailure = _onFailure_;
    }
    const _maxRetries_ = json["maxRetries"] ?? json["max_retries"];
    if (_maxRetries_) {
      msg.maxRetries = protoscript.parseNumber(_maxRetries_);
    }
    const _timeoutSeconds_ = json["timeoutSeconds"] ?? json["timeout_seconds"];
    if (_timeoutSeconds_) {
      msg.timeoutSeconds = protoscript.parseNumber(_timeoutSeconds_);
    }
    return msg;
  },

  Variables: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<CreateWorkflowRequest.Variables>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: CreateWorkflowRequest.Variables,
      json: any,
    ): CreateWorkflowRequest.Variables {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const GetWorkflowRequestJSON = {
  /**
   * Serializes GetWorkflowRequest to JSON.
   */
  encode: function (msg: PartialDeep<GetWorkflowRequest>): string {
    return JSON.stringify(GetWorkflowRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetWorkflowRequest from JSON.
   */
  decode: function (json: string): GetWorkflowRequest {
    return GetWorkflowRequestJSON._readMessage(
      GetWorkflowRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GetWorkflowRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<GetWorkflowRequest>): GetWorkflowRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetWorkflowRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetWorkflowRequest,
    json: any,
  ): GetWorkflowRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    return msg;
  },
};

export const WorkflowResponseJSON = {
  /**
   * Serializes WorkflowResponse to JSON.
   */
  encode: function (msg: PartialDeep<WorkflowResponse>): string {
    return JSON.stringify(WorkflowResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes WorkflowResponse from JSON.
   */
  decode: function (json: string): WorkflowResponse {
    return WorkflowResponseJSON._readMessage(
      WorkflowResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WorkflowResponse with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WorkflowResponse>): WorkflowResponse {
    return {
      status: common.ResponseStatusJSON.initialize(),
      workflow: WorkflowJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WorkflowResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.status) {
      const _status_ = common.ResponseStatusJSON._writeMessage(msg.status);
      if (Object.keys(_status_).length > 0) {
        json["status"] = _status_;
      }
    }
    if (msg.workflow) {
      const _workflow_ = WorkflowJSON._writeMessage(msg.workflow);
      if (Object.keys(_workflow_).length > 0) {
        json["workflow"] = _workflow_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: WorkflowResponse, json: any): WorkflowResponse {
    const _status_ = json["status"];
    if (_status_) {
      common.ResponseStatusJSON._readMessage(msg.status, _status_);
    }
    const _workflow_ = json["workflow"];
    if (_workflow_) {
      WorkflowJSON._readMessage(msg.workflow, _workflow_);
    }
    return msg;
  },
};

export const UpdateWorkflowRequestJSON = {
  /**
   * Serializes UpdateWorkflowRequest to JSON.
   */
  encode: function (msg: PartialDeep<UpdateWorkflowRequest>): string {
    return JSON.stringify(UpdateWorkflowRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes UpdateWorkflowRequest from JSON.
   */
  decode: function (json: string): UpdateWorkflowRequest {
    return UpdateWorkflowRequestJSON._readMessage(
      UpdateWorkflowRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes UpdateWorkflowRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<UpdateWorkflowRequest>,
  ): UpdateWorkflowRequest {
    return {
      id: "",
      name: "",
      description: "",
      enabled: false,
      steps: [],
      variables: {},
      onSuccess: "",
      onFailure: "",
      maxRetries: 0,
      timeoutSeconds: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UpdateWorkflowRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.description) {
      json["description"] = msg.description;
    }
    if (msg.enabled) {
      json["enabled"] = msg.enabled;
    }
    if (msg.steps?.length) {
      json["steps"] = msg.steps.map(WorkflowStepJSON._writeMessage);
    }
    if (msg.variables) {
      const _variables_ = Object.fromEntries(
        Object.entries(msg.variables)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(UpdateWorkflowRequestJSON.Variables._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_variables_).length > 0) {
        json["variables"] = _variables_;
      }
    }
    if (msg.onSuccess) {
      json["onSuccess"] = msg.onSuccess;
    }
    if (msg.onFailure) {
      json["onFailure"] = msg.onFailure;
    }
    if (msg.maxRetries) {
      json["maxRetries"] = msg.maxRetries;
    }
    if (msg.timeoutSeconds) {
      json["timeoutSeconds"] = msg.timeoutSeconds;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UpdateWorkflowRequest,
    json: any,
  ): UpdateWorkflowRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _enabled_ = json["enabled"];
    if (_enabled_) {
      msg.enabled = _enabled_;
    }
    const _steps_ = json["steps"];
    if (_steps_) {
      for (const item of _steps_) {
        const m = WorkflowStepJSON.initialize();
        WorkflowStepJSON._readMessage(m, item);
        msg.steps.push(m);
      }
    }
    const _variables_ = json["variables"];
    if (_variables_) {
      msg.variables = Object.fromEntries(
        Object.entries(_variables_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(UpdateWorkflowRequestJSON.Variables._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _onSuccess_ = json["onSuccess"] ?? json["on_success"];
    if (_onSuccess_) {
      msg.onSuccess = _onSuccess_;
    }
    const _onFailure_ = json["onFailure"] ?? json["on_failure"];
    if (_onFailure_) {
      msg.onFailure = _onFailure_;
    }
    const _maxRetries_ = json["maxRetries"] ?? json["max_retries"];
    if (_maxRetries_) {
      msg.maxRetries = protoscript.parseNumber(_maxRetries_);
    }
    const _timeoutSeconds_ = json["timeoutSeconds"] ?? json["timeout_seconds"];
    if (_timeoutSeconds_) {
      msg.timeoutSeconds = protoscript.parseNumber(_timeoutSeconds_);
    }
    return msg;
  },

  Variables: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<UpdateWorkflowRequest.Variables>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: UpdateWorkflowRequest.Variables,
      json: any,
    ): UpdateWorkflowRequest.Variables {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const DeleteWorkflowRequestJSON = {
  /**
   * Serializes DeleteWorkflowRequest to JSON.
   */
  encode: function (msg: PartialDeep<DeleteWorkflowRequest>): string {
    return JSON.stringify(DeleteWorkflowRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes DeleteWorkflowRequest from JSON.
   */
  decode: function (json: string): DeleteWorkflowRequest {
    return DeleteWorkflowRequestJSON._readMessage(
      DeleteWorkflowRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes DeleteWorkflowRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<DeleteWorkflowRequest>,
  ): DeleteWorkflowRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DeleteWorkflowRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DeleteWorkflowRequest,
    json: any,
  ): DeleteWorkflowRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    return msg;
  },
};

export const ListWorkflowsRequestJSON = {
  /**
   * Serializes ListWorkflowsRequest to JSON.
   */
  encode: function (msg: PartialDeep<ListWorkflowsRequest>): string {
    return JSON.stringify(ListWorkflowsRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListWorkflowsRequest from JSON.
   */
  decode: function (json: string): ListWorkflowsRequest {
    return ListWorkflowsRequestJSON._readMessage(
      ListWorkflowsRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListWorkflowsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListWorkflowsRequest>,
  ): ListWorkflowsRequest {
    return {
      applicationId: "",
      includeDisabled: false,
      page: 0,
      pageSize: 0,
      sortBy: "",
      sortDesc: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListWorkflowsRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.applicationId) {
      json["applicationId"] = msg.applicationId;
    }
    if (msg.includeDisabled) {
      json["includeDisabled"] = msg.includeDisabled;
    }
    if (msg.page) {
      json["page"] = msg.page;
    }
    if (msg.pageSize) {
      json["pageSize"] = msg.pageSize;
    }
    if (msg.sortBy) {
      json["sortBy"] = msg.sortBy;
    }
    if (msg.sortDesc) {
      json["sortDesc"] = msg.sortDesc;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListWorkflowsRequest,
    json: any,
  ): ListWorkflowsRequest {
    const _applicationId_ = json["applicationId"] ?? json["application_id"];
    if (_applicationId_) {
      msg.applicationId = _applicationId_;
    }
    const _includeDisabled_ =
      json["includeDisabled"] ?? json["include_disabled"];
    if (_includeDisabled_) {
      msg.includeDisabled = _includeDisabled_;
    }
    const _page_ = json["page"];
    if (_page_) {
      msg.page = protoscript.parseNumber(_page_);
    }
    const _pageSize_ = json["pageSize"] ?? json["page_size"];
    if (_pageSize_) {
      msg.pageSize = protoscript.parseNumber(_pageSize_);
    }
    const _sortBy_ = json["sortBy"] ?? json["sort_by"];
    if (_sortBy_) {
      msg.sortBy = _sortBy_;
    }
    const _sortDesc_ = json["sortDesc"] ?? json["sort_desc"];
    if (_sortDesc_) {
      msg.sortDesc = _sortDesc_;
    }
    return msg;
  },
};

export const ListWorkflowsResponseJSON = {
  /**
   * Serializes ListWorkflowsResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListWorkflowsResponse>): string {
    return JSON.stringify(ListWorkflowsResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListWorkflowsResponse from JSON.
   */
  decode: function (json: string): ListWorkflowsResponse {
    return ListWorkflowsResponseJSON._readMessage(
      ListWorkflowsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListWorkflowsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListWorkflowsResponse>,
  ): ListWorkflowsResponse {
    return {
      status: common.ResponseStatusJSON.initialize(),
      workflows: [],
      totalCount: 0,
      page: 0,
      pageSize: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListWorkflowsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.status) {
      const _status_ = common.ResponseStatusJSON._writeMessage(msg.status);
      if (Object.keys(_status_).length > 0) {
        json["status"] = _status_;
      }
    }
    if (msg.workflows?.length) {
      json["workflows"] = msg.workflows.map(WorkflowJSON._writeMessage);
    }
    if (msg.totalCount) {
      json["totalCount"] = msg.totalCount;
    }
    if (msg.page) {
      json["page"] = msg.page;
    }
    if (msg.pageSize) {
      json["pageSize"] = msg.pageSize;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListWorkflowsResponse,
    json: any,
  ): ListWorkflowsResponse {
    const _status_ = json["status"];
    if (_status_) {
      common.ResponseStatusJSON._readMessage(msg.status, _status_);
    }
    const _workflows_ = json["workflows"];
    if (_workflows_) {
      for (const item of _workflows_) {
        const m = WorkflowJSON.initialize();
        WorkflowJSON._readMessage(m, item);
        msg.workflows.push(m);
      }
    }
    const _totalCount_ = json["totalCount"] ?? json["total_count"];
    if (_totalCount_) {
      msg.totalCount = protoscript.parseNumber(_totalCount_);
    }
    const _page_ = json["page"];
    if (_page_) {
      msg.page = protoscript.parseNumber(_page_);
    }
    const _pageSize_ = json["pageSize"] ?? json["page_size"];
    if (_pageSize_) {
      msg.pageSize = protoscript.parseNumber(_pageSize_);
    }
    return msg;
  },
};

export const ExecuteWorkflowRequestJSON = {
  /**
   * Serializes ExecuteWorkflowRequest to JSON.
   */
  encode: function (msg: PartialDeep<ExecuteWorkflowRequest>): string {
    return JSON.stringify(ExecuteWorkflowRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ExecuteWorkflowRequest from JSON.
   */
  decode: function (json: string): ExecuteWorkflowRequest {
    return ExecuteWorkflowRequestJSON._readMessage(
      ExecuteWorkflowRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ExecuteWorkflowRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ExecuteWorkflowRequest>,
  ): ExecuteWorkflowRequest {
    return {
      workflowId: "",
      applicationId: "",
      startedBy: "",
      inputs: {},
      async: false,
      correlationId: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ExecuteWorkflowRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.workflowId) {
      json["workflowId"] = msg.workflowId;
    }
    if (msg.applicationId) {
      json["applicationId"] = msg.applicationId;
    }
    if (msg.startedBy) {
      json["startedBy"] = msg.startedBy;
    }
    if (msg.inputs) {
      const _inputs_ = Object.fromEntries(
        Object.entries(msg.inputs)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(ExecuteWorkflowRequestJSON.Inputs._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_inputs_).length > 0) {
        json["inputs"] = _inputs_;
      }
    }
    if (msg.async) {
      json["async"] = msg.async;
    }
    if (msg.correlationId) {
      json["correlationId"] = msg.correlationId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ExecuteWorkflowRequest,
    json: any,
  ): ExecuteWorkflowRequest {
    const _workflowId_ = json["workflowId"] ?? json["workflow_id"];
    if (_workflowId_) {
      msg.workflowId = _workflowId_;
    }
    const _applicationId_ = json["applicationId"] ?? json["application_id"];
    if (_applicationId_) {
      msg.applicationId = _applicationId_;
    }
    const _startedBy_ = json["startedBy"] ?? json["started_by"];
    if (_startedBy_) {
      msg.startedBy = _startedBy_;
    }
    const _inputs_ = json["inputs"];
    if (_inputs_) {
      msg.inputs = Object.fromEntries(
        Object.entries(_inputs_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(ExecuteWorkflowRequestJSON.Inputs._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _async_ = json["async"];
    if (_async_) {
      msg.async = _async_;
    }
    const _correlationId_ = json["correlationId"] ?? json["correlation_id"];
    if (_correlationId_) {
      msg.correlationId = _correlationId_;
    }
    return msg;
  },

  Inputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ExecuteWorkflowRequest.Inputs>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ExecuteWorkflowRequest.Inputs,
      json: any,
    ): ExecuteWorkflowRequest.Inputs {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const ExecuteWorkflowResponseJSON = {
  /**
   * Serializes ExecuteWorkflowResponse to JSON.
   */
  encode: function (msg: PartialDeep<ExecuteWorkflowResponse>): string {
    return JSON.stringify(ExecuteWorkflowResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes ExecuteWorkflowResponse from JSON.
   */
  decode: function (json: string): ExecuteWorkflowResponse {
    return ExecuteWorkflowResponseJSON._readMessage(
      ExecuteWorkflowResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ExecuteWorkflowResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ExecuteWorkflowResponse>,
  ): ExecuteWorkflowResponse {
    return {
      status: common.ResponseStatusJSON.initialize(),
      executionId: "",
      async: false,
      statusUrl: "",
      outputs: {},
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ExecuteWorkflowResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.status) {
      const _status_ = common.ResponseStatusJSON._writeMessage(msg.status);
      if (Object.keys(_status_).length > 0) {
        json["status"] = _status_;
      }
    }
    if (msg.executionId) {
      json["executionId"] = msg.executionId;
    }
    if (msg.async) {
      json["async"] = msg.async;
    }
    if (msg.statusUrl) {
      json["statusUrl"] = msg.statusUrl;
    }
    if (msg.outputs) {
      const _outputs_ = Object.fromEntries(
        Object.entries(msg.outputs)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(ExecuteWorkflowResponseJSON.Outputs._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_outputs_).length > 0) {
        json["outputs"] = _outputs_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ExecuteWorkflowResponse,
    json: any,
  ): ExecuteWorkflowResponse {
    const _status_ = json["status"];
    if (_status_) {
      common.ResponseStatusJSON._readMessage(msg.status, _status_);
    }
    const _executionId_ = json["executionId"] ?? json["execution_id"];
    if (_executionId_) {
      msg.executionId = _executionId_;
    }
    const _async_ = json["async"];
    if (_async_) {
      msg.async = _async_;
    }
    const _statusUrl_ = json["statusUrl"] ?? json["status_url"];
    if (_statusUrl_) {
      msg.statusUrl = _statusUrl_;
    }
    const _outputs_ = json["outputs"];
    if (_outputs_) {
      msg.outputs = Object.fromEntries(
        Object.entries(_outputs_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(ExecuteWorkflowResponseJSON.Outputs._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  Outputs: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<ExecuteWorkflowResponse.Outputs>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: ExecuteWorkflowResponse.Outputs,
      json: any,
    ): ExecuteWorkflowResponse.Outputs {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const GetWorkflowExecutionRequestJSON = {
  /**
   * Serializes GetWorkflowExecutionRequest to JSON.
   */
  encode: function (msg: PartialDeep<GetWorkflowExecutionRequest>): string {
    return JSON.stringify(GetWorkflowExecutionRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetWorkflowExecutionRequest from JSON.
   */
  decode: function (json: string): GetWorkflowExecutionRequest {
    return GetWorkflowExecutionRequestJSON._readMessage(
      GetWorkflowExecutionRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GetWorkflowExecutionRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetWorkflowExecutionRequest>,
  ): GetWorkflowExecutionRequest {
    return {
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetWorkflowExecutionRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetWorkflowExecutionRequest,
    json: any,
  ): GetWorkflowExecutionRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    return msg;
  },
};

export const WorkflowExecutionResponseJSON = {
  /**
   * Serializes WorkflowExecutionResponse to JSON.
   */
  encode: function (msg: PartialDeep<WorkflowExecutionResponse>): string {
    return JSON.stringify(WorkflowExecutionResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes WorkflowExecutionResponse from JSON.
   */
  decode: function (json: string): WorkflowExecutionResponse {
    return WorkflowExecutionResponseJSON._readMessage(
      WorkflowExecutionResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WorkflowExecutionResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<WorkflowExecutionResponse>,
  ): WorkflowExecutionResponse {
    return {
      status: common.ResponseStatusJSON.initialize(),
      execution: WorkflowExecutionJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WorkflowExecutionResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.status) {
      const _status_ = common.ResponseStatusJSON._writeMessage(msg.status);
      if (Object.keys(_status_).length > 0) {
        json["status"] = _status_;
      }
    }
    if (msg.execution) {
      const _execution_ = WorkflowExecutionJSON._writeMessage(msg.execution);
      if (Object.keys(_execution_).length > 0) {
        json["execution"] = _execution_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WorkflowExecutionResponse,
    json: any,
  ): WorkflowExecutionResponse {
    const _status_ = json["status"];
    if (_status_) {
      common.ResponseStatusJSON._readMessage(msg.status, _status_);
    }
    const _execution_ = json["execution"];
    if (_execution_) {
      WorkflowExecutionJSON._readMessage(msg.execution, _execution_);
    }
    return msg;
  },
};

export const ListWorkflowExecutionsRequestJSON = {
  /**
   * Serializes ListWorkflowExecutionsRequest to JSON.
   */
  encode: function (msg: PartialDeep<ListWorkflowExecutionsRequest>): string {
    return JSON.stringify(ListWorkflowExecutionsRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes ListWorkflowExecutionsRequest from JSON.
   */
  decode: function (json: string): ListWorkflowExecutionsRequest {
    return ListWorkflowExecutionsRequestJSON._readMessage(
      ListWorkflowExecutionsRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListWorkflowExecutionsRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListWorkflowExecutionsRequest>,
  ): ListWorkflowExecutionsRequest {
    return {
      workflowId: "",
      applicationId: "",
      status: "",
      startedBy: "",
      from: protoscript.TimestampJSON.initialize(),
      to: protoscript.TimestampJSON.initialize(),
      page: 0,
      pageSize: 0,
      sortBy: "",
      sortDesc: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListWorkflowExecutionsRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.workflowId) {
      json["workflowId"] = msg.workflowId;
    }
    if (msg.applicationId) {
      json["applicationId"] = msg.applicationId;
    }
    if (msg.status) {
      json["status"] = msg.status;
    }
    if (msg.startedBy) {
      json["startedBy"] = msg.startedBy;
    }
    if (msg.from && (msg.from.seconds || msg.from.nanos)) {
      json["from"] = protoscript.serializeTimestamp(msg.from);
    }
    if (msg.to && (msg.to.seconds || msg.to.nanos)) {
      json["to"] = protoscript.serializeTimestamp(msg.to);
    }
    if (msg.page) {
      json["page"] = msg.page;
    }
    if (msg.pageSize) {
      json["pageSize"] = msg.pageSize;
    }
    if (msg.sortBy) {
      json["sortBy"] = msg.sortBy;
    }
    if (msg.sortDesc) {
      json["sortDesc"] = msg.sortDesc;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListWorkflowExecutionsRequest,
    json: any,
  ): ListWorkflowExecutionsRequest {
    const _workflowId_ = json["workflowId"] ?? json["workflow_id"];
    if (_workflowId_) {
      msg.workflowId = _workflowId_;
    }
    const _applicationId_ = json["applicationId"] ?? json["application_id"];
    if (_applicationId_) {
      msg.applicationId = _applicationId_;
    }
    const _status_ = json["status"];
    if (_status_) {
      msg.status = _status_;
    }
    const _startedBy_ = json["startedBy"] ?? json["started_by"];
    if (_startedBy_) {
      msg.startedBy = _startedBy_;
    }
    const _from_ = json["from"];
    if (_from_) {
      msg.from = protoscript.parseTimestamp(_from_);
    }
    const _to_ = json["to"];
    if (_to_) {
      msg.to = protoscript.parseTimestamp(_to_);
    }
    const _page_ = json["page"];
    if (_page_) {
      msg.page = protoscript.parseNumber(_page_);
    }
    const _pageSize_ = json["pageSize"] ?? json["page_size"];
    if (_pageSize_) {
      msg.pageSize = protoscript.parseNumber(_pageSize_);
    }
    const _sortBy_ = json["sortBy"] ?? json["sort_by"];
    if (_sortBy_) {
      msg.sortBy = _sortBy_;
    }
    const _sortDesc_ = json["sortDesc"] ?? json["sort_desc"];
    if (_sortDesc_) {
      msg.sortDesc = _sortDesc_;
    }
    return msg;
  },
};

export const ListWorkflowExecutionsResponseJSON = {
  /**
   * Serializes ListWorkflowExecutionsResponse to JSON.
   */
  encode: function (msg: PartialDeep<ListWorkflowExecutionsResponse>): string {
    return JSON.stringify(
      ListWorkflowExecutionsResponseJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes ListWorkflowExecutionsResponse from JSON.
   */
  decode: function (json: string): ListWorkflowExecutionsResponse {
    return ListWorkflowExecutionsResponseJSON._readMessage(
      ListWorkflowExecutionsResponseJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ListWorkflowExecutionsResponse with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<ListWorkflowExecutionsResponse>,
  ): ListWorkflowExecutionsResponse {
    return {
      status: common.ResponseStatusJSON.initialize(),
      executions: [],
      totalCount: 0,
      page: 0,
      pageSize: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ListWorkflowExecutionsResponse>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.status) {
      const _status_ = common.ResponseStatusJSON._writeMessage(msg.status);
      if (Object.keys(_status_).length > 0) {
        json["status"] = _status_;
      }
    }
    if (msg.executions?.length) {
      json["executions"] = msg.executions.map(
        WorkflowExecutionJSON._writeMessage,
      );
    }
    if (msg.totalCount) {
      json["totalCount"] = msg.totalCount;
    }
    if (msg.page) {
      json["page"] = msg.page;
    }
    if (msg.pageSize) {
      json["pageSize"] = msg.pageSize;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ListWorkflowExecutionsResponse,
    json: any,
  ): ListWorkflowExecutionsResponse {
    const _status_ = json["status"];
    if (_status_) {
      common.ResponseStatusJSON._readMessage(msg.status, _status_);
    }
    const _executions_ = json["executions"];
    if (_executions_) {
      for (const item of _executions_) {
        const m = WorkflowExecutionJSON.initialize();
        WorkflowExecutionJSON._readMessage(m, item);
        msg.executions.push(m);
      }
    }
    const _totalCount_ = json["totalCount"] ?? json["total_count"];
    if (_totalCount_) {
      msg.totalCount = protoscript.parseNumber(_totalCount_);
    }
    const _page_ = json["page"];
    if (_page_) {
      msg.page = protoscript.parseNumber(_page_);
    }
    const _pageSize_ = json["pageSize"] ?? json["page_size"];
    if (_pageSize_) {
      msg.pageSize = protoscript.parseNumber(_pageSize_);
    }
    return msg;
  },
};

export const CancelWorkflowExecutionRequestJSON = {
  /**
   * Serializes CancelWorkflowExecutionRequest to JSON.
   */
  encode: function (msg: PartialDeep<CancelWorkflowExecutionRequest>): string {
    return JSON.stringify(
      CancelWorkflowExecutionRequestJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes CancelWorkflowExecutionRequest from JSON.
   */
  decode: function (json: string): CancelWorkflowExecutionRequest {
    return CancelWorkflowExecutionRequestJSON._readMessage(
      CancelWorkflowExecutionRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CancelWorkflowExecutionRequest with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<CancelWorkflowExecutionRequest>,
  ): CancelWorkflowExecutionRequest {
    return {
      id: "",
      reason: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CancelWorkflowExecutionRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.reason) {
      json["reason"] = msg.reason;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CancelWorkflowExecutionRequest,
    json: any,
  ): CancelWorkflowExecutionRequest {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    const _reason_ = json["reason"];
    if (_reason_) {
      msg.reason = _reason_;
    }
    return msg;
  },
};
